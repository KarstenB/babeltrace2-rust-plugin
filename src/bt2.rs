//This file is automatically generated
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::missing_safety_doc)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::ffi::CStr;
use num_derive::{FromPrimitive, ToPrimitive};
pub mod binding {
  include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
  include!("binding_additions.rs");
}
use binding::*;


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtClockClassCyclesToNsFromOriginStatus {
  Ok = bt_clock_class_cycles_to_ns_from_origin_status_BT_CLOCK_CLASS_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK,
  OverflowError = bt_clock_class_cycles_to_ns_from_origin_status_BT_CLOCK_CLASS_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR,
}
impl From< i32 > for BtClockClassCyclesToNsFromOriginStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtClockClassCyclesToNsFromOriginStatus > for i32 {
  fn from(item: BtClockClassCyclesToNsFromOriginStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtClockClassSetDescriptionStatus {
  Ok = bt_clock_class_set_description_status_BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_OK,
  MemoryError = bt_clock_class_set_description_status_BT_CLOCK_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtClockClassSetDescriptionStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtClockClassSetDescriptionStatus > for i32 {
  fn from(item: BtClockClassSetDescriptionStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtClockClassSetNameStatus {
  Ok = bt_clock_class_set_name_status_BT_CLOCK_CLASS_SET_NAME_STATUS_OK,
  MemoryError = bt_clock_class_set_name_status_BT_CLOCK_CLASS_SET_NAME_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtClockClassSetNameStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtClockClassSetNameStatus > for i32 {
  fn from(item: BtClockClassSetNameStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtClockSnapshotGetNsFromOriginStatus {
  Ok = bt_clock_snapshot_get_ns_from_origin_status_BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OK,
  OverflowError = bt_clock_snapshot_get_ns_from_origin_status_BT_CLOCK_SNAPSHOT_GET_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR,
}
impl From< i32 > for BtClockSnapshotGetNsFromOriginStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtClockSnapshotGetNsFromOriginStatus > for i32 {
  fn from(item: BtClockSnapshotGetNsFromOriginStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassGetSupportedMipVersionsMethodStatus {
  Ok = bt_component_class_get_supported_mip_versions_method_status_BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_OK,
  MemoryError = bt_component_class_get_supported_mip_versions_method_status_BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_get_supported_mip_versions_method_status_BT_COMPONENT_CLASS_GET_SUPPORTED_MIP_VERSIONS_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassGetSupportedMipVersionsMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassGetSupportedMipVersionsMethodStatus > for i32 {
  fn from(item: BtComponentClassGetSupportedMipVersionsMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassInitializeMethodStatus {
  Ok = bt_component_class_initialize_method_status_BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_OK,
  MemoryError = bt_component_class_initialize_method_status_BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_initialize_method_status_BT_COMPONENT_CLASS_INITIALIZE_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassInitializeMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassInitializeMethodStatus > for i32 {
  fn from(item: BtComponentClassInitializeMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassPortConnectedMethodStatus {
  Ok = bt_component_class_port_connected_method_status_BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_OK,
  MemoryError = bt_component_class_port_connected_method_status_BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_port_connected_method_status_BT_COMPONENT_CLASS_PORT_CONNECTED_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassPortConnectedMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassPortConnectedMethodStatus > for i32 {
  fn from(item: BtComponentClassPortConnectedMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassQueryMethodStatus {
  Ok = bt_component_class_query_method_status_BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_OK,
  UnknownObject = bt_component_class_query_method_status_BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_UNKNOWN_OBJECT,
  Again = bt_component_class_query_method_status_BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_AGAIN,
  MemoryError = bt_component_class_query_method_status_BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_query_method_status_BT_COMPONENT_CLASS_QUERY_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassQueryMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassQueryMethodStatus > for i32 {
  fn from(item: BtComponentClassQueryMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassSetDescriptionStatus {
  Ok = bt_component_class_set_description_status_BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_OK,
  MemoryError = bt_component_class_set_description_status_BT_COMPONENT_CLASS_SET_DESCRIPTION_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtComponentClassSetDescriptionStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassSetDescriptionStatus > for i32 {
  fn from(item: BtComponentClassSetDescriptionStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassSetHelpStatus {
  Ok = bt_component_class_set_help_status_BT_COMPONENT_CLASS_SET_HELP_STATUS_OK,
  MemoryError = bt_component_class_set_help_status_BT_COMPONENT_CLASS_SET_HELP_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtComponentClassSetHelpStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassSetHelpStatus > for i32 {
  fn from(item: BtComponentClassSetHelpStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassSetMethodStatus {
  Ok = bt_component_class_set_method_status_BT_COMPONENT_CLASS_SET_METHOD_STATUS_OK,
}
impl From< u32 > for BtComponentClassSetMethodStatus {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtComponentClassSetMethodStatus > for u32 {
  fn from(item: BtComponentClassSetMethodStatus) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassSinkConsumeMethodStatus {
  Ok = bt_component_class_sink_consume_method_status_BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_OK,
  End = bt_component_class_sink_consume_method_status_BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_END,
  Again = bt_component_class_sink_consume_method_status_BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_AGAIN,
  MemoryError = bt_component_class_sink_consume_method_status_BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_sink_consume_method_status_BT_COMPONENT_CLASS_SINK_CONSUME_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassSinkConsumeMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassSinkConsumeMethodStatus > for i32 {
  fn from(item: BtComponentClassSinkConsumeMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassSinkGraphIsConfiguredMethodStatus {
  Ok = bt_component_class_sink_graph_is_configured_method_status_BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_OK,
  MemoryError = bt_component_class_sink_graph_is_configured_method_status_BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_component_class_sink_graph_is_configured_method_status_BT_COMPONENT_CLASS_SINK_GRAPH_IS_CONFIGURED_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtComponentClassSinkGraphIsConfiguredMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentClassSinkGraphIsConfiguredMethodStatus > for i32 {
  fn from(item: BtComponentClassSinkGraphIsConfiguredMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentClassType {
  Source = bt_component_class_type_BT_COMPONENT_CLASS_TYPE_SOURCE,
  Filter = bt_component_class_type_BT_COMPONENT_CLASS_TYPE_FILTER,
  Sink = bt_component_class_type_BT_COMPONENT_CLASS_TYPE_SINK,
}
impl From< u32 > for BtComponentClassType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtComponentClassType > for u32 {
  fn from(item: BtComponentClassType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtComponentDescriptorSetAddDescriptorStatus {
  Ok = bt_component_descriptor_set_add_descriptor_status_BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_OK,
  MemoryError = bt_component_descriptor_set_add_descriptor_status_BT_COMPONENT_DESCRIPTOR_SET_ADD_DESCRIPTOR_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtComponentDescriptorSetAddDescriptorStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtComponentDescriptorSetAddDescriptorStatus > for i32 {
  fn from(item: BtComponentDescriptorSetAddDescriptorStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtCurrentThreadErrorAppendCauseStatus {
  Ok = bt_current_thread_error_append_cause_status_BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_OK,
  MemoryError = bt_current_thread_error_append_cause_status_BT_CURRENT_THREAD_ERROR_APPEND_CAUSE_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtCurrentThreadErrorAppendCauseStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtCurrentThreadErrorAppendCauseStatus > for i32 {
  fn from(item: BtCurrentThreadErrorAppendCauseStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtErrorCauseActorType {
  Unknown = bt_error_cause_actor_type_BT_ERROR_CAUSE_ACTOR_TYPE_UNKNOWN,
  Component = bt_error_cause_actor_type_BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT,
  ComponentClass = bt_error_cause_actor_type_BT_ERROR_CAUSE_ACTOR_TYPE_COMPONENT_CLASS,
  MessageIterator = bt_error_cause_actor_type_BT_ERROR_CAUSE_ACTOR_TYPE_MESSAGE_ITERATOR,
}
impl From< u32 > for BtErrorCauseActorType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtErrorCauseActorType > for u32 {
  fn from(item: BtErrorCauseActorType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtEventClassLogLevel {
  Emergency = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_EMERGENCY,
  Alert = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_ALERT,
  Critical = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_CRITICAL,
  Error = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_ERROR,
  Warning = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_WARNING,
  Notice = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_NOTICE,
  Info = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_INFO,
  DebugSystem = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_SYSTEM,
  DebugProgram = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_PROGRAM,
  DebugProcess = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_PROCESS,
  DebugModule = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_MODULE,
  DebugUnit = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_UNIT,
  DebugFunction = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_FUNCTION,
  DebugLine = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG_LINE,
  Debug = bt_event_class_log_level_BT_EVENT_CLASS_LOG_LEVEL_DEBUG,
}
impl From< u32 > for BtEventClassLogLevel {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtEventClassLogLevel > for u32 {
  fn from(item: BtEventClassLogLevel) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtEventClassSetEmfUriStatus {
  Ok = bt_event_class_set_emf_uri_status_BT_EVENT_CLASS_SET_EMF_URI_STATUS_OK,
  MemoryError = bt_event_class_set_emf_uri_status_BT_EVENT_CLASS_SET_EMF_URI_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtEventClassSetEmfUriStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtEventClassSetEmfUriStatus > for i32 {
  fn from(item: BtEventClassSetEmfUriStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtEventClassSetFieldClassStatus {
  Ok = bt_event_class_set_field_class_status_BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_OK,
  MemoryError = bt_event_class_set_field_class_status_BT_EVENT_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtEventClassSetFieldClassStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtEventClassSetFieldClassStatus > for i32 {
  fn from(item: BtEventClassSetFieldClassStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtEventClassSetNameStatus {
  Ok = bt_event_class_set_name_status_BT_EVENT_CLASS_SET_NAME_STATUS_OK,
  MemoryError = bt_event_class_set_name_status_BT_EVENT_CLASS_SET_NAME_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtEventClassSetNameStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtEventClassSetNameStatus > for i32 {
  fn from(item: BtEventClassSetNameStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldArrayDynamicSetLengthStatus {
  BtFieldDynamicArraySetLengthStatusOk = bt_field_array_dynamic_set_length_status_BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_OK,
  BtFieldDynamicArraySetLengthStatusMemoryError = bt_field_array_dynamic_set_length_status_BT_FIELD_DYNAMIC_ARRAY_SET_LENGTH_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldArrayDynamicSetLengthStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldArrayDynamicSetLengthStatus > for i32 {
  fn from(item: BtFieldArrayDynamicSetLengthStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassEnumerationAddMappingStatus {
  Ok = bt_field_class_enumeration_add_mapping_status_BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_OK,
  MemoryError = bt_field_class_enumeration_add_mapping_status_BT_FIELD_CLASS_ENUMERATION_ADD_MAPPING_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldClassEnumerationAddMappingStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldClassEnumerationAddMappingStatus > for i32 {
  fn from(item: BtFieldClassEnumerationAddMappingStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassEnumerationGetMappingLabelsForValueStatus {
  BtFieldClassEnumerationGetMappingLabelsByValueStatusOk = bt_field_class_enumeration_get_mapping_labels_for_value_status_BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_OK,
  BtFieldClassEnumerationGetMappingLabelsByValueStatusMemoryError = bt_field_class_enumeration_get_mapping_labels_for_value_status_BT_FIELD_CLASS_ENUMERATION_GET_MAPPING_LABELS_BY_VALUE_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldClassEnumerationGetMappingLabelsForValueStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldClassEnumerationGetMappingLabelsForValueStatus > for i32 {
  fn from(item: BtFieldClassEnumerationGetMappingLabelsForValueStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassIntegerPreferredDisplayBase {
  Binary = bt_field_class_integer_preferred_display_base_BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_BINARY,
  Octal = bt_field_class_integer_preferred_display_base_BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_OCTAL,
  Decimal = bt_field_class_integer_preferred_display_base_BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_DECIMAL,
  Hexadecimal = bt_field_class_integer_preferred_display_base_BT_FIELD_CLASS_INTEGER_PREFERRED_DISPLAY_BASE_HEXADECIMAL,
}
impl From< u32 > for BtFieldClassIntegerPreferredDisplayBase {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtFieldClassIntegerPreferredDisplayBase > for u32 {
  fn from(item: BtFieldClassIntegerPreferredDisplayBase) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassStructureAppendMemberStatus {
  Ok = bt_field_class_structure_append_member_status_BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_OK,
  MemoryError = bt_field_class_structure_append_member_status_BT_FIELD_CLASS_STRUCTURE_APPEND_MEMBER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldClassStructureAppendMemberStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldClassStructureAppendMemberStatus > for i32 {
  fn from(item: BtFieldClassStructureAppendMemberStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u64)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassType {
  Bool = bt_field_class_type_BT_FIELD_CLASS_TYPE_BOOL,
  BitArray = bt_field_class_type_BT_FIELD_CLASS_TYPE_BIT_ARRAY,
  Integer = bt_field_class_type_BT_FIELD_CLASS_TYPE_INTEGER,
  UnsignedInteger = bt_field_class_type_BT_FIELD_CLASS_TYPE_UNSIGNED_INTEGER,
  SignedInteger = bt_field_class_type_BT_FIELD_CLASS_TYPE_SIGNED_INTEGER,
  Enumeration = bt_field_class_type_BT_FIELD_CLASS_TYPE_ENUMERATION,
  UnsignedEnumeration = bt_field_class_type_BT_FIELD_CLASS_TYPE_UNSIGNED_ENUMERATION,
  SignedEnumeration = bt_field_class_type_BT_FIELD_CLASS_TYPE_SIGNED_ENUMERATION,
  Real = bt_field_class_type_BT_FIELD_CLASS_TYPE_REAL,
  SinglePrecisionReal = bt_field_class_type_BT_FIELD_CLASS_TYPE_SINGLE_PRECISION_REAL,
  DoublePrecisionReal = bt_field_class_type_BT_FIELD_CLASS_TYPE_DOUBLE_PRECISION_REAL,
  String = bt_field_class_type_BT_FIELD_CLASS_TYPE_STRING,
  Structure = bt_field_class_type_BT_FIELD_CLASS_TYPE_STRUCTURE,
  Array = bt_field_class_type_BT_FIELD_CLASS_TYPE_ARRAY,
  StaticArray = bt_field_class_type_BT_FIELD_CLASS_TYPE_STATIC_ARRAY,
  DynamicArray = bt_field_class_type_BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY,
  DynamicArrayWithoutLengthField = bt_field_class_type_BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY_WITHOUT_LENGTH_FIELD,
  DynamicArrayWithLengthField = bt_field_class_type_BT_FIELD_CLASS_TYPE_DYNAMIC_ARRAY_WITH_LENGTH_FIELD,
  Option = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION,
  OptionWithoutSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITHOUT_SELECTOR_FIELD,
  OptionWithSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITH_SELECTOR_FIELD,
  OptionWithBoolSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITH_BOOL_SELECTOR_FIELD,
  OptionWithIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITH_INTEGER_SELECTOR_FIELD,
  OptionWithUnsignedIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITH_UNSIGNED_INTEGER_SELECTOR_FIELD,
  OptionWithSignedIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_OPTION_WITH_SIGNED_INTEGER_SELECTOR_FIELD,
  Variant = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT,
  VariantWithoutSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT_WITHOUT_SELECTOR_FIELD,
  VariantWithSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT_WITH_SELECTOR_FIELD,
  VariantWithIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT_WITH_INTEGER_SELECTOR_FIELD,
  VariantWithUnsignedIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT_WITH_UNSIGNED_INTEGER_SELECTOR_FIELD,
  VariantWithSignedIntegerSelectorField = bt_field_class_type_BT_FIELD_CLASS_TYPE_VARIANT_WITH_SIGNED_INTEGER_SELECTOR_FIELD,
  BtFieldClassTypeBigValue = bt_field_class_type___BT_FIELD_CLASS_TYPE_BIG_VALUE,
}
impl From< u64 > for BtFieldClassType {
  fn from(item: u64) -> Self {
    num::FromPrimitive::from_u64(item).unwrap()
  }
}
impl From< BtFieldClassType > for u64 {
  fn from(item: BtFieldClassType) -> Self {
    num::ToPrimitive::to_u64(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus {
  BtFieldClassVariantWithSelectorFieldAppendOptionStatusOk = bt_field_class_variant_with_selector_field_integer_append_option_status_BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK,
  BtFieldClassVariantWithSelectorFieldAppendOptionStatusMemoryError = bt_field_class_variant_with_selector_field_integer_append_option_status_BT_FIELD_CLASS_VARIANT_WITH_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus > for i32 {
  fn from(item: BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldClassVariantWithoutSelectorAppendOptionStatus {
  BtFieldClassVariantWithoutSelectorFieldAppendOptionStatusOk = bt_field_class_variant_without_selector_append_option_status_BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_OK,
  BtFieldClassVariantWithoutSelectorFieldAppendOptionStatusMemoryError = bt_field_class_variant_without_selector_append_option_status_BT_FIELD_CLASS_VARIANT_WITHOUT_SELECTOR_FIELD_APPEND_OPTION_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldClassVariantWithoutSelectorAppendOptionStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldClassVariantWithoutSelectorAppendOptionStatus > for i32 {
  fn from(item: BtFieldClassVariantWithoutSelectorAppendOptionStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldEnumerationGetMappingLabelsStatus {
  Ok = bt_field_enumeration_get_mapping_labels_status_BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_OK,
  MemoryError = bt_field_enumeration_get_mapping_labels_status_BT_FIELD_ENUMERATION_GET_MAPPING_LABELS_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldEnumerationGetMappingLabelsStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldEnumerationGetMappingLabelsStatus > for i32 {
  fn from(item: BtFieldEnumerationGetMappingLabelsStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldPathItemType {
  Index = bt_field_path_item_type_BT_FIELD_PATH_ITEM_TYPE_INDEX,
  CurrentArrayElement = bt_field_path_item_type_BT_FIELD_PATH_ITEM_TYPE_CURRENT_ARRAY_ELEMENT,
  CurrentOptionContent = bt_field_path_item_type_BT_FIELD_PATH_ITEM_TYPE_CURRENT_OPTION_CONTENT,
}
impl From< u32 > for BtFieldPathItemType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtFieldPathItemType > for u32 {
  fn from(item: BtFieldPathItemType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldPathScope {
  PacketContext = bt_field_path_scope_BT_FIELD_PATH_SCOPE_PACKET_CONTEXT,
  EventCommonContext = bt_field_path_scope_BT_FIELD_PATH_SCOPE_EVENT_COMMON_CONTEXT,
  EventSpecificContext = bt_field_path_scope_BT_FIELD_PATH_SCOPE_EVENT_SPECIFIC_CONTEXT,
  EventPayload = bt_field_path_scope_BT_FIELD_PATH_SCOPE_EVENT_PAYLOAD,
}
impl From< u32 > for BtFieldPathScope {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtFieldPathScope > for u32 {
  fn from(item: BtFieldPathScope) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldStringAppendStatus {
  Ok = bt_field_string_append_status_BT_FIELD_STRING_APPEND_STATUS_OK,
  MemoryError = bt_field_string_append_status_BT_FIELD_STRING_APPEND_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldStringAppendStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldStringAppendStatus > for i32 {
  fn from(item: BtFieldStringAppendStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldStringSetValueStatus {
  Ok = bt_field_string_set_value_status_BT_FIELD_STRING_SET_VALUE_STATUS_OK,
  MemoryError = bt_field_string_set_value_status_BT_FIELD_STRING_SET_VALUE_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtFieldStringSetValueStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtFieldStringSetValueStatus > for i32 {
  fn from(item: BtFieldStringSetValueStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtFieldVariantSelectOptionByIndexStatus {
  BtFieldVariantSelectOptionStatusOk = bt_field_variant_select_option_by_index_status_BT_FIELD_VARIANT_SELECT_OPTION_STATUS_OK,
}
impl From< u32 > for BtFieldVariantSelectOptionByIndexStatus {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtFieldVariantSelectOptionByIndexStatus > for u32 {
  fn from(item: BtFieldVariantSelectOptionByIndexStatus) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGetGreatestOperativeMipVersionStatus {
  Ok = bt_get_greatest_operative_mip_version_status_BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_OK,
  NoMatch = bt_get_greatest_operative_mip_version_status_BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_NO_MATCH,
  MemoryError = bt_get_greatest_operative_mip_version_status_BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_MEMORY_ERROR,
  Error = bt_get_greatest_operative_mip_version_status_BT_GET_GREATEST_OPERATIVE_MIP_VERSION_STATUS_ERROR,
}
impl From< i32 > for BtGetGreatestOperativeMipVersionStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGetGreatestOperativeMipVersionStatus > for i32 {
  fn from(item: BtGetGreatestOperativeMipVersionStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphAddComponentStatus {
  Ok = bt_graph_add_component_status_BT_GRAPH_ADD_COMPONENT_STATUS_OK,
  MemoryError = bt_graph_add_component_status_BT_GRAPH_ADD_COMPONENT_STATUS_MEMORY_ERROR,
  Error = bt_graph_add_component_status_BT_GRAPH_ADD_COMPONENT_STATUS_ERROR,
}
impl From< i32 > for BtGraphAddComponentStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphAddComponentStatus > for i32 {
  fn from(item: BtGraphAddComponentStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphAddInterrupterStatus {
  Ok = bt_graph_add_interrupter_status_BT_GRAPH_ADD_INTERRUPTER_STATUS_OK,
  MemoryError = bt_graph_add_interrupter_status_BT_GRAPH_ADD_INTERRUPTER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtGraphAddInterrupterStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphAddInterrupterStatus > for i32 {
  fn from(item: BtGraphAddInterrupterStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphAddListenerStatus {
  Ok = bt_graph_add_listener_status_BT_GRAPH_ADD_LISTENER_STATUS_OK,
  MemoryError = bt_graph_add_listener_status_BT_GRAPH_ADD_LISTENER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtGraphAddListenerStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphAddListenerStatus > for i32 {
  fn from(item: BtGraphAddListenerStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphConnectPortsStatus {
  Ok = bt_graph_connect_ports_status_BT_GRAPH_CONNECT_PORTS_STATUS_OK,
  MemoryError = bt_graph_connect_ports_status_BT_GRAPH_CONNECT_PORTS_STATUS_MEMORY_ERROR,
  Error = bt_graph_connect_ports_status_BT_GRAPH_CONNECT_PORTS_STATUS_ERROR,
}
impl From< i32 > for BtGraphConnectPortsStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphConnectPortsStatus > for i32 {
  fn from(item: BtGraphConnectPortsStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphListenerFuncStatus {
  Ok = bt_graph_listener_func_status_BT_GRAPH_LISTENER_FUNC_STATUS_OK,
  MemoryError = bt_graph_listener_func_status_BT_GRAPH_LISTENER_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_graph_listener_func_status_BT_GRAPH_LISTENER_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtGraphListenerFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphListenerFuncStatus > for i32 {
  fn from(item: BtGraphListenerFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphRunOnceStatus {
  Ok = bt_graph_run_once_status_BT_GRAPH_RUN_ONCE_STATUS_OK,
  End = bt_graph_run_once_status_BT_GRAPH_RUN_ONCE_STATUS_END,
  Again = bt_graph_run_once_status_BT_GRAPH_RUN_ONCE_STATUS_AGAIN,
  MemoryError = bt_graph_run_once_status_BT_GRAPH_RUN_ONCE_STATUS_MEMORY_ERROR,
  Error = bt_graph_run_once_status_BT_GRAPH_RUN_ONCE_STATUS_ERROR,
}
impl From< i32 > for BtGraphRunOnceStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphRunOnceStatus > for i32 {
  fn from(item: BtGraphRunOnceStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphRunStatus {
  Ok = bt_graph_run_status_BT_GRAPH_RUN_STATUS_OK,
  Again = bt_graph_run_status_BT_GRAPH_RUN_STATUS_AGAIN,
  MemoryError = bt_graph_run_status_BT_GRAPH_RUN_STATUS_MEMORY_ERROR,
  Error = bt_graph_run_status_BT_GRAPH_RUN_STATUS_ERROR,
}
impl From< i32 > for BtGraphRunStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphRunStatus > for i32 {
  fn from(item: BtGraphRunStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphSimpleSinkComponentConsumeFuncStatus {
  Ok = bt_graph_simple_sink_component_consume_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_OK,
  End = bt_graph_simple_sink_component_consume_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_END,
  Again = bt_graph_simple_sink_component_consume_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_AGAIN,
  MemoryError = bt_graph_simple_sink_component_consume_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_graph_simple_sink_component_consume_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_CONSUME_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtGraphSimpleSinkComponentConsumeFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphSimpleSinkComponentConsumeFuncStatus > for i32 {
  fn from(item: BtGraphSimpleSinkComponentConsumeFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtGraphSimpleSinkComponentInitializeFuncStatus {
  Ok = bt_graph_simple_sink_component_initialize_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_OK,
  MemoryError = bt_graph_simple_sink_component_initialize_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_graph_simple_sink_component_initialize_func_status_BT_GRAPH_SIMPLE_SINK_COMPONENT_INITIALIZE_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtGraphSimpleSinkComponentInitializeFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtGraphSimpleSinkComponentInitializeFuncStatus > for i32 {
  fn from(item: BtGraphSimpleSinkComponentInitializeFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtIntegerRangeSetAddRangeStatus {
  Ok = bt_integer_range_set_add_range_status_BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_OK,
  MemoryError = bt_integer_range_set_add_range_status_BT_INTEGER_RANGE_SET_ADD_RANGE_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtIntegerRangeSetAddRangeStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtIntegerRangeSetAddRangeStatus > for i32 {
  fn from(item: BtIntegerRangeSetAddRangeStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtLoggingLevel {
  Trace = bt_logging_level_BT_LOGGING_LEVEL_TRACE,
  Debug = bt_logging_level_BT_LOGGING_LEVEL_DEBUG,
  Info = bt_logging_level_BT_LOGGING_LEVEL_INFO,
  Warning = bt_logging_level_BT_LOGGING_LEVEL_WARNING,
  Error = bt_logging_level_BT_LOGGING_LEVEL_ERROR,
  Fatal = bt_logging_level_BT_LOGGING_LEVEL_FATAL,
  None = bt_logging_level_BT_LOGGING_LEVEL_NONE,
}
impl From< u32 > for BtLoggingLevel {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtLoggingLevel > for u32 {
  fn from(item: BtLoggingLevel) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorCanSeekBeginningStatus {
  Ok = bt_message_iterator_can_seek_beginning_status_BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_OK,
  Again = bt_message_iterator_can_seek_beginning_status_BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_AGAIN,
  MemoryError = bt_message_iterator_can_seek_beginning_status_BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_can_seek_beginning_status_BT_MESSAGE_ITERATOR_CAN_SEEK_BEGINNING_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorCanSeekBeginningStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorCanSeekBeginningStatus > for i32 {
  fn from(item: BtMessageIteratorCanSeekBeginningStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorCanSeekNsFromOriginStatus {
  Ok = bt_message_iterator_can_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_OK,
  Again = bt_message_iterator_can_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN,
  MemoryError = bt_message_iterator_can_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_can_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_CAN_SEEK_NS_FROM_ORIGIN_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorCanSeekNsFromOriginStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorCanSeekNsFromOriginStatus > for i32 {
  fn from(item: BtMessageIteratorCanSeekNsFromOriginStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassCanSeekBeginningMethodStatus {
  Ok = bt_message_iterator_class_can_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_OK,
  Again = bt_message_iterator_class_can_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_AGAIN,
  MemoryError = bt_message_iterator_class_can_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_can_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_BEGINNING_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassCanSeekBeginningMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassCanSeekBeginningMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassCanSeekBeginningMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassCanSeekNsFromOriginMethodStatus {
  Ok = bt_message_iterator_class_can_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK,
  Again = bt_message_iterator_class_can_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN,
  MemoryError = bt_message_iterator_class_can_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_can_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_CAN_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassCanSeekNsFromOriginMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassCanSeekNsFromOriginMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassCanSeekNsFromOriginMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassInitializeMethodStatus {
  Ok = bt_message_iterator_class_initialize_method_status_BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_OK,
  MemoryError = bt_message_iterator_class_initialize_method_status_BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_initialize_method_status_BT_MESSAGE_ITERATOR_CLASS_INITIALIZE_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassInitializeMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassInitializeMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassInitializeMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassNextMethodStatus {
  Ok = bt_message_iterator_class_next_method_status_BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_OK,
  End = bt_message_iterator_class_next_method_status_BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_END,
  Again = bt_message_iterator_class_next_method_status_BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_AGAIN,
  MemoryError = bt_message_iterator_class_next_method_status_BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_next_method_status_BT_MESSAGE_ITERATOR_CLASS_NEXT_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassNextMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassNextMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassNextMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassSeekBeginningMethodStatus {
  Ok = bt_message_iterator_class_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_OK,
  Again = bt_message_iterator_class_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_AGAIN,
  MemoryError = bt_message_iterator_class_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_seek_beginning_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_BEGINNING_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassSeekBeginningMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassSeekBeginningMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassSeekBeginningMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassSeekNsFromOriginMethodStatus {
  Ok = bt_message_iterator_class_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_OK,
  Again = bt_message_iterator_class_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_AGAIN,
  MemoryError = bt_message_iterator_class_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_class_seek_ns_from_origin_method_status_BT_MESSAGE_ITERATOR_CLASS_SEEK_NS_FROM_ORIGIN_METHOD_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorClassSeekNsFromOriginMethodStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassSeekNsFromOriginMethodStatus > for i32 {
  fn from(item: BtMessageIteratorClassSeekNsFromOriginMethodStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorClassSetMethodStatus {
  Ok = bt_message_iterator_class_set_method_status_BT_MESSAGE_ITERATOR_CLASS_SET_METHOD_STATUS_OK,
}
impl From< u32 > for BtMessageIteratorClassSetMethodStatus {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtMessageIteratorClassSetMethodStatus > for u32 {
  fn from(item: BtMessageIteratorClassSetMethodStatus) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorCreateFromMessageIteratorStatus {
  Ok = bt_message_iterator_create_from_message_iterator_status_BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_OK,
  MemoryError = bt_message_iterator_create_from_message_iterator_status_BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_create_from_message_iterator_status_BT_MESSAGE_ITERATOR_CREATE_FROM_MESSAGE_ITERATOR_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorCreateFromMessageIteratorStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorCreateFromMessageIteratorStatus > for i32 {
  fn from(item: BtMessageIteratorCreateFromMessageIteratorStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorCreateFromSinkComponentStatus {
  Ok = bt_message_iterator_create_from_sink_component_status_BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_OK,
  MemoryError = bt_message_iterator_create_from_sink_component_status_BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_create_from_sink_component_status_BT_MESSAGE_ITERATOR_CREATE_FROM_SINK_COMPONENT_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorCreateFromSinkComponentStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorCreateFromSinkComponentStatus > for i32 {
  fn from(item: BtMessageIteratorCreateFromSinkComponentStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorNextStatus {
  Ok = bt_message_iterator_next_status_BT_MESSAGE_ITERATOR_NEXT_STATUS_OK,
  End = bt_message_iterator_next_status_BT_MESSAGE_ITERATOR_NEXT_STATUS_END,
  Again = bt_message_iterator_next_status_BT_MESSAGE_ITERATOR_NEXT_STATUS_AGAIN,
  MemoryError = bt_message_iterator_next_status_BT_MESSAGE_ITERATOR_NEXT_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_next_status_BT_MESSAGE_ITERATOR_NEXT_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorNextStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorNextStatus > for i32 {
  fn from(item: BtMessageIteratorNextStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorSeekBeginningStatus {
  Ok = bt_message_iterator_seek_beginning_status_BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_OK,
  Again = bt_message_iterator_seek_beginning_status_BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_AGAIN,
  MemoryError = bt_message_iterator_seek_beginning_status_BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_seek_beginning_status_BT_MESSAGE_ITERATOR_SEEK_BEGINNING_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorSeekBeginningStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorSeekBeginningStatus > for i32 {
  fn from(item: BtMessageIteratorSeekBeginningStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageIteratorSeekNsFromOriginStatus {
  Ok = bt_message_iterator_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_OK,
  Again = bt_message_iterator_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_AGAIN,
  MemoryError = bt_message_iterator_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_MEMORY_ERROR,
  Error = bt_message_iterator_seek_ns_from_origin_status_BT_MESSAGE_ITERATOR_SEEK_NS_FROM_ORIGIN_STATUS_ERROR,
}
impl From< i32 > for BtMessageIteratorSeekNsFromOriginStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtMessageIteratorSeekNsFromOriginStatus > for i32 {
  fn from(item: BtMessageIteratorSeekNsFromOriginStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageStreamClockSnapshotState {
  Known = bt_message_stream_clock_snapshot_state_BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_KNOWN,
  Unknown = bt_message_stream_clock_snapshot_state_BT_MESSAGE_STREAM_CLOCK_SNAPSHOT_STATE_UNKNOWN,
}
impl From< u32 > for BtMessageStreamClockSnapshotState {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtMessageStreamClockSnapshotState > for u32 {
  fn from(item: BtMessageStreamClockSnapshotState) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtMessageType {
  StreamBeginning = bt_message_type_BT_MESSAGE_TYPE_STREAM_BEGINNING,
  StreamEnd = bt_message_type_BT_MESSAGE_TYPE_STREAM_END,
  Event = bt_message_type_BT_MESSAGE_TYPE_EVENT,
  PacketBeginning = bt_message_type_BT_MESSAGE_TYPE_PACKET_BEGINNING,
  PacketEnd = bt_message_type_BT_MESSAGE_TYPE_PACKET_END,
  DiscardedEvents = bt_message_type_BT_MESSAGE_TYPE_DISCARDED_EVENTS,
  DiscardedPackets = bt_message_type_BT_MESSAGE_TYPE_DISCARDED_PACKETS,
  MessageIteratorInactivity = bt_message_type_BT_MESSAGE_TYPE_MESSAGE_ITERATOR_INACTIVITY,
}
impl From< u32 > for BtMessageType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtMessageType > for u32 {
  fn from(item: BtMessageType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginFindAllFromDirStatus {
  Ok = bt_plugin_find_all_from_dir_status_BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_OK,
  NotFound = bt_plugin_find_all_from_dir_status_BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_NOT_FOUND,
  MemoryError = bt_plugin_find_all_from_dir_status_BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_MEMORY_ERROR,
  Error = bt_plugin_find_all_from_dir_status_BT_PLUGIN_FIND_ALL_FROM_DIR_STATUS_ERROR,
}
impl From< i32 > for BtPluginFindAllFromDirStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginFindAllFromDirStatus > for i32 {
  fn from(item: BtPluginFindAllFromDirStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginFindAllFromFileStatus {
  Ok = bt_plugin_find_all_from_file_status_BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_OK,
  NotFound = bt_plugin_find_all_from_file_status_BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_NOT_FOUND,
  MemoryError = bt_plugin_find_all_from_file_status_BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_MEMORY_ERROR,
  Error = bt_plugin_find_all_from_file_status_BT_PLUGIN_FIND_ALL_FROM_FILE_STATUS_ERROR,
}
impl From< i32 > for BtPluginFindAllFromFileStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginFindAllFromFileStatus > for i32 {
  fn from(item: BtPluginFindAllFromFileStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginFindAllFromStaticStatus {
  Ok = bt_plugin_find_all_from_static_status_BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_OK,
  NotFound = bt_plugin_find_all_from_static_status_BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_NOT_FOUND,
  MemoryError = bt_plugin_find_all_from_static_status_BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_MEMORY_ERROR,
  Error = bt_plugin_find_all_from_static_status_BT_PLUGIN_FIND_ALL_FROM_STATIC_STATUS_ERROR,
}
impl From< i32 > for BtPluginFindAllFromStaticStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginFindAllFromStaticStatus > for i32 {
  fn from(item: BtPluginFindAllFromStaticStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginFindAllStatus {
  Ok = bt_plugin_find_all_status_BT_PLUGIN_FIND_ALL_STATUS_OK,
  NotFound = bt_plugin_find_all_status_BT_PLUGIN_FIND_ALL_STATUS_NOT_FOUND,
  MemoryError = bt_plugin_find_all_status_BT_PLUGIN_FIND_ALL_STATUS_MEMORY_ERROR,
  Error = bt_plugin_find_all_status_BT_PLUGIN_FIND_ALL_STATUS_ERROR,
}
impl From< i32 > for BtPluginFindAllStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginFindAllStatus > for i32 {
  fn from(item: BtPluginFindAllStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginFindStatus {
  Ok = bt_plugin_find_status_BT_PLUGIN_FIND_STATUS_OK,
  NotFound = bt_plugin_find_status_BT_PLUGIN_FIND_STATUS_NOT_FOUND,
  MemoryError = bt_plugin_find_status_BT_PLUGIN_FIND_STATUS_MEMORY_ERROR,
  Error = bt_plugin_find_status_BT_PLUGIN_FIND_STATUS_ERROR,
}
impl From< i32 > for BtPluginFindStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginFindStatus > for i32 {
  fn from(item: BtPluginFindStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPluginInitializeFuncStatus {
  Ok = bt_plugin_initialize_func_status_BT_PLUGIN_INITIALIZE_FUNC_STATUS_OK,
  MemoryError = bt_plugin_initialize_func_status_BT_PLUGIN_INITIALIZE_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_plugin_initialize_func_status_BT_PLUGIN_INITIALIZE_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtPluginInitializeFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtPluginInitializeFuncStatus > for i32 {
  fn from(item: BtPluginInitializeFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPortType {
  Input = bt_port_type_BT_PORT_TYPE_INPUT,
  Output = bt_port_type_BT_PORT_TYPE_OUTPUT,
}
impl From< u32 > for BtPortType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtPortType > for u32 {
  fn from(item: BtPortType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtPropertyAvailability {
  Available = bt_property_availability_BT_PROPERTY_AVAILABILITY_AVAILABLE,
  NotAvailable = bt_property_availability_BT_PROPERTY_AVAILABILITY_NOT_AVAILABLE,
}
impl From< u32 > for BtPropertyAvailability {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtPropertyAvailability > for u32 {
  fn from(item: BtPropertyAvailability) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtQueryExecutorAddInterrupterStatus {
  Ok = bt_query_executor_add_interrupter_status_BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_OK,
  MemoryError = bt_query_executor_add_interrupter_status_BT_QUERY_EXECUTOR_ADD_INTERRUPTER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtQueryExecutorAddInterrupterStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtQueryExecutorAddInterrupterStatus > for i32 {
  fn from(item: BtQueryExecutorAddInterrupterStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtQueryExecutorQueryStatus {
  Ok = bt_query_executor_query_status_BT_QUERY_EXECUTOR_QUERY_STATUS_OK,
  UnknownObject = bt_query_executor_query_status_BT_QUERY_EXECUTOR_QUERY_STATUS_UNKNOWN_OBJECT,
  Again = bt_query_executor_query_status_BT_QUERY_EXECUTOR_QUERY_STATUS_AGAIN,
  MemoryError = bt_query_executor_query_status_BT_QUERY_EXECUTOR_QUERY_STATUS_MEMORY_ERROR,
  Error = bt_query_executor_query_status_BT_QUERY_EXECUTOR_QUERY_STATUS_ERROR,
}
impl From< i32 > for BtQueryExecutorQueryStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtQueryExecutorQueryStatus > for i32 {
  fn from(item: BtQueryExecutorQueryStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtQueryExecutorSetLoggingLevelStatus {
  Ok = bt_query_executor_set_logging_level_status_BT_QUERY_EXECUTOR_SET_LOGGING_LEVEL_STATUS_OK,
}
impl From< u32 > for BtQueryExecutorSetLoggingLevelStatus {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtQueryExecutorSetLoggingLevelStatus > for u32 {
  fn from(item: BtQueryExecutorSetLoggingLevelStatus) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtSelfComponentAddPortStatus {
  Ok = bt_self_component_add_port_status_BT_SELF_COMPONENT_ADD_PORT_STATUS_OK,
  MemoryError = bt_self_component_add_port_status_BT_SELF_COMPONENT_ADD_PORT_STATUS_MEMORY_ERROR,
  Error = bt_self_component_add_port_status_BT_SELF_COMPONENT_ADD_PORT_STATUS_ERROR,
}
impl From< i32 > for BtSelfComponentAddPortStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtSelfComponentAddPortStatus > for i32 {
  fn from(item: BtSelfComponentAddPortStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtStreamClassSetDefaultClockClassStatus {
  Ok = bt_stream_class_set_default_clock_class_status_BT_STREAM_CLASS_SET_DEFAULT_CLOCK_CLASS_STATUS_OK,
}
impl From< u32 > for BtStreamClassSetDefaultClockClassStatus {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtStreamClassSetDefaultClockClassStatus > for u32 {
  fn from(item: BtStreamClassSetDefaultClockClassStatus) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtStreamClassSetFieldClassStatus {
  Ok = bt_stream_class_set_field_class_status_BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_OK,
  MemoryError = bt_stream_class_set_field_class_status_BT_STREAM_CLASS_SET_FIELD_CLASS_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtStreamClassSetFieldClassStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtStreamClassSetFieldClassStatus > for i32 {
  fn from(item: BtStreamClassSetFieldClassStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtStreamClassSetNameStatus {
  Ok = bt_stream_class_set_name_status_BT_STREAM_CLASS_SET_NAME_STATUS_OK,
  MemoryError = bt_stream_class_set_name_status_BT_STREAM_CLASS_SET_NAME_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtStreamClassSetNameStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtStreamClassSetNameStatus > for i32 {
  fn from(item: BtStreamClassSetNameStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtStreamSetNameStatus {
  Ok = bt_stream_set_name_status_BT_STREAM_SET_NAME_STATUS_OK,
  MemoryError = bt_stream_set_name_status_BT_STREAM_SET_NAME_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtStreamSetNameStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtStreamSetNameStatus > for i32 {
  fn from(item: BtStreamSetNameStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceAddListenerStatus {
  Ok = bt_trace_add_listener_status_BT_TRACE_ADD_LISTENER_STATUS_OK,
  MemoryError = bt_trace_add_listener_status_BT_TRACE_ADD_LISTENER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceAddListenerStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceAddListenerStatus > for i32 {
  fn from(item: BtTraceAddListenerStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceClassAddListenerStatus {
  Ok = bt_trace_class_add_listener_status_BT_TRACE_CLASS_ADD_LISTENER_STATUS_OK,
  MemoryError = bt_trace_class_add_listener_status_BT_TRACE_CLASS_ADD_LISTENER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceClassAddListenerStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceClassAddListenerStatus > for i32 {
  fn from(item: BtTraceClassAddListenerStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceClassRemoveListenerStatus {
  Ok = bt_trace_class_remove_listener_status_BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_OK,
  MemoryError = bt_trace_class_remove_listener_status_BT_TRACE_CLASS_REMOVE_LISTENER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceClassRemoveListenerStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceClassRemoveListenerStatus > for i32 {
  fn from(item: BtTraceClassRemoveListenerStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceRemoveListenerStatus {
  Ok = bt_trace_remove_listener_status_BT_TRACE_REMOVE_LISTENER_STATUS_OK,
  MemoryError = bt_trace_remove_listener_status_BT_TRACE_REMOVE_LISTENER_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceRemoveListenerStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceRemoveListenerStatus > for i32 {
  fn from(item: BtTraceRemoveListenerStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceSetEnvironmentEntryStatus {
  Ok = bt_trace_set_environment_entry_status_BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_OK,
  MemoryError = bt_trace_set_environment_entry_status_BT_TRACE_SET_ENVIRONMENT_ENTRY_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceSetEnvironmentEntryStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceSetEnvironmentEntryStatus > for i32 {
  fn from(item: BtTraceSetEnvironmentEntryStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtTraceSetNameStatus {
  Ok = bt_trace_set_name_status_BT_TRACE_SET_NAME_STATUS_OK,
  MemoryError = bt_trace_set_name_status_BT_TRACE_SET_NAME_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtTraceSetNameStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtTraceSetNameStatus > for i32 {
  fn from(item: BtTraceSetNameStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtUtilClockCyclesToNsFromOriginStatus {
  Ok = bt_util_clock_cycles_to_ns_from_origin_status_BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OK,
  OverflowError = bt_util_clock_cycles_to_ns_from_origin_status_BT_UTIL_CLOCK_CYCLES_TO_NS_FROM_ORIGIN_STATUS_OVERFLOW_ERROR,
}
impl From< i32 > for BtUtilClockCyclesToNsFromOriginStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtUtilClockCyclesToNsFromOriginStatus > for i32 {
  fn from(item: BtUtilClockCyclesToNsFromOriginStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueArrayAppendElementStatus {
  Ok = bt_value_array_append_element_status_BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_OK,
  MemoryError = bt_value_array_append_element_status_BT_VALUE_ARRAY_APPEND_ELEMENT_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueArrayAppendElementStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueArrayAppendElementStatus > for i32 {
  fn from(item: BtValueArrayAppendElementStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueArraySetElementByIndexStatus {
  Ok = bt_value_array_set_element_by_index_status_BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_OK,
  MemoryError = bt_value_array_set_element_by_index_status_BT_VALUE_ARRAY_SET_ELEMENT_BY_INDEX_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueArraySetElementByIndexStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueArraySetElementByIndexStatus > for i32 {
  fn from(item: BtValueArraySetElementByIndexStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueCopyStatus {
  Ok = bt_value_copy_status_BT_VALUE_COPY_STATUS_OK,
  MemoryError = bt_value_copy_status_BT_VALUE_COPY_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueCopyStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueCopyStatus > for i32 {
  fn from(item: BtValueCopyStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapExtendStatus {
  Ok = bt_value_map_extend_status_BT_VALUE_MAP_EXTEND_STATUS_OK,
  MemoryError = bt_value_map_extend_status_BT_VALUE_MAP_EXTEND_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueMapExtendStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapExtendStatus > for i32 {
  fn from(item: BtValueMapExtendStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapForeachEntryConstFuncStatus {
  Ok = bt_value_map_foreach_entry_const_func_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_OK,
  Interrupt = bt_value_map_foreach_entry_const_func_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_INTERRUPT,
  MemoryError = bt_value_map_foreach_entry_const_func_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_value_map_foreach_entry_const_func_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtValueMapForeachEntryConstFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapForeachEntryConstFuncStatus > for i32 {
  fn from(item: BtValueMapForeachEntryConstFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapForeachEntryConstStatus {
  Ok = bt_value_map_foreach_entry_const_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_OK,
  Interrupted = bt_value_map_foreach_entry_const_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_INTERRUPTED,
  UserError = bt_value_map_foreach_entry_const_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_USER_ERROR,
  MemoryError = bt_value_map_foreach_entry_const_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_MEMORY_ERROR,
  Error = bt_value_map_foreach_entry_const_status_BT_VALUE_MAP_FOREACH_ENTRY_CONST_STATUS_ERROR,
}
impl From< i32 > for BtValueMapForeachEntryConstStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapForeachEntryConstStatus > for i32 {
  fn from(item: BtValueMapForeachEntryConstStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapForeachEntryFuncStatus {
  Ok = bt_value_map_foreach_entry_func_status_BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_OK,
  Interrupt = bt_value_map_foreach_entry_func_status_BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_INTERRUPT,
  MemoryError = bt_value_map_foreach_entry_func_status_BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_MEMORY_ERROR,
  Error = bt_value_map_foreach_entry_func_status_BT_VALUE_MAP_FOREACH_ENTRY_FUNC_STATUS_ERROR,
}
impl From< i32 > for BtValueMapForeachEntryFuncStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapForeachEntryFuncStatus > for i32 {
  fn from(item: BtValueMapForeachEntryFuncStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapForeachEntryStatus {
  Ok = bt_value_map_foreach_entry_status_BT_VALUE_MAP_FOREACH_ENTRY_STATUS_OK,
  Interrupted = bt_value_map_foreach_entry_status_BT_VALUE_MAP_FOREACH_ENTRY_STATUS_INTERRUPTED,
  UserError = bt_value_map_foreach_entry_status_BT_VALUE_MAP_FOREACH_ENTRY_STATUS_USER_ERROR,
  MemoryError = bt_value_map_foreach_entry_status_BT_VALUE_MAP_FOREACH_ENTRY_STATUS_MEMORY_ERROR,
  Error = bt_value_map_foreach_entry_status_BT_VALUE_MAP_FOREACH_ENTRY_STATUS_ERROR,
}
impl From< i32 > for BtValueMapForeachEntryStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapForeachEntryStatus > for i32 {
  fn from(item: BtValueMapForeachEntryStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueMapInsertEntryStatus {
  Ok = bt_value_map_insert_entry_status_BT_VALUE_MAP_INSERT_ENTRY_STATUS_OK,
  MemoryError = bt_value_map_insert_entry_status_BT_VALUE_MAP_INSERT_ENTRY_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueMapInsertEntryStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueMapInsertEntryStatus > for i32 {
  fn from(item: BtValueMapInsertEntryStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(i32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueStringSetStatus {
  Ok = bt_value_string_set_status_BT_VALUE_STRING_SET_STATUS_OK,
  MemoryError = bt_value_string_set_status_BT_VALUE_STRING_SET_STATUS_MEMORY_ERROR,
}
impl From< i32 > for BtValueStringSetStatus {
  fn from(item: i32) -> Self {
    num::FromPrimitive::from_i32(item).unwrap()
  }
}
impl From< BtValueStringSetStatus > for i32 {
  fn from(item: BtValueStringSetStatus) -> Self {
    num::ToPrimitive::to_i32(&item).unwrap()
  }
}


#[repr(u32)]
#[derive(FromPrimitive, ToPrimitive, Debug, PartialEq, PartialOrd, Copy, Clone)]
pub enum BtValueType {
  Null = bt_value_type_BT_VALUE_TYPE_NULL,
  Bool = bt_value_type_BT_VALUE_TYPE_BOOL,
  Integer = bt_value_type_BT_VALUE_TYPE_INTEGER,
  UnsignedInteger = bt_value_type_BT_VALUE_TYPE_UNSIGNED_INTEGER,
  SignedInteger = bt_value_type_BT_VALUE_TYPE_SIGNED_INTEGER,
  Real = bt_value_type_BT_VALUE_TYPE_REAL,
  String = bt_value_type_BT_VALUE_TYPE_STRING,
  Array = bt_value_type_BT_VALUE_TYPE_ARRAY,
  Map = bt_value_type_BT_VALUE_TYPE_MAP,
}
impl From< u32 > for BtValueType {
  fn from(item: u32) -> Self {
    num::FromPrimitive::from_u32(item).unwrap()
  }
}
impl From< BtValueType > for u32 {
  fn from(item: BtValueType) -> Self {
    num::ToPrimitive::to_u32(&item).unwrap()
  }
}


pub struct BtClockClassConst {
    ptr: *const bt_clock_class
}
impl BtClockClassConst {
    pub fn empty() -> BtClockClassConst {
        BtClockClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_clock_class) -> BtClockClassConst {
        BtClockClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_frequency(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_frequency(self.ptr) }
  }

  pub unsafe fn get_offset(&self, offset_seconds: *mut i64, offset_cycles: *mut u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_offset(self.ptr, offset_seconds, offset_cycles) }
  }

  pub fn get_precision(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_precision(self.ptr) }
  }

  pub fn origin_is_unix_epoch(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_clock_class_origin_is_unix_epoch(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_clock_class_get_name(self.ptr)) }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_clock_class_get_description(self.ptr)) }
  }

  pub fn get_uuid(&self) -> bt_uuid {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_uuid(self.ptr) }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_clock_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn cycles_to_ns_from_origin(&self, value: u64, ns_from_origin: *mut i64) -> BtClockClassCyclesToNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_class_cycles_to_ns_from_origin(self.ptr, value, ns_from_origin)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_put_ref(self.ptr) }
  }

}
pub struct BtClockClass {
    ptr: *mut bt_clock_class
}
impl BtClockClass {
    pub fn empty() -> BtClockClass {
        BtClockClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_clock_class) -> BtClockClass {
        BtClockClass { ptr }
    }
    pub fn as_const(&mut self) -> BtClockClassConst {
      BtClockClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(self_component: &BtSelfComponent) -> BtClockClass {
    unsafe { BtClockClass{ ptr:bt_clock_class_create(self_component.ptr)} }
  }

  pub fn set_frequency(&mut self, frequency: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_frequency(self.ptr, frequency) }
  }

  pub fn get_frequency(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_frequency(self.ptr) }
  }

  pub fn set_offset(&mut self, offset_seconds: i64, offset_cycles: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_offset(self.ptr, offset_seconds, offset_cycles) }
  }

  pub unsafe fn get_offset(&self, offset_seconds: *mut i64, offset_cycles: *mut u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_offset(self.ptr, offset_seconds, offset_cycles) }
  }

  pub fn set_precision(&mut self, precision: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_precision(self.ptr, precision) }
  }

  pub fn get_precision(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_precision(self.ptr) }
  }

  pub fn set_origin_is_unix_epoch(&mut self, origin_is_unix_epoch: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_origin_is_unix_epoch(self.ptr, if origin_is_unix_epoch { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn origin_is_unix_epoch(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_clock_class_origin_is_unix_epoch(self.ptr) as u32) != BT_FALSE }
  }

  pub unsafe fn set_name(&mut self, name: &str) -> BtClockClassSetNameStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_class_set_name(self.ptr, name.as_ptr())).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_clock_class_get_name(self.ptr)) }
  }

  pub unsafe fn set_description(&mut self, description: &str) -> BtClockClassSetDescriptionStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_class_set_description(self.ptr, description.as_ptr())).unwrap() }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_clock_class_get_description(self.ptr)) }
  }

  pub unsafe fn set_uuid(&mut self, uuid: bt_uuid)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_uuid(self.ptr, uuid) }
  }

  pub fn get_uuid(&self) -> bt_uuid {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_uuid(self.ptr) }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_clock_class_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_clock_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn cycles_to_ns_from_origin(&self, value: u64, ns_from_origin: *mut i64) -> BtClockClassCyclesToNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_class_cycles_to_ns_from_origin(self.ptr, value, ns_from_origin)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_class_put_ref(self.ptr) }
  }

}
pub struct BtClockSnapshotConst {
    ptr: *const bt_clock_snapshot
}
impl BtClockSnapshotConst {
    pub fn empty() -> BtClockSnapshotConst {
        BtClockSnapshotConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_clock_snapshot) -> BtClockSnapshotConst {
        BtClockSnapshotConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_clock_snapshot_borrow_clock_class_const(self.ptr)} }
  }

  pub fn get_value(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_snapshot_get_value(self.ptr) }
  }

  pub unsafe fn get_ns_from_origin(&self, ns_from_origin: *mut i64) -> BtClockSnapshotGetNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_snapshot_get_ns_from_origin(self.ptr, ns_from_origin)).unwrap() }
  }

}
pub struct BtClockSnapshot {
    ptr: *mut bt_clock_snapshot
}
impl BtClockSnapshot {
    pub fn empty() -> BtClockSnapshot {
        BtClockSnapshot { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_clock_snapshot) -> BtClockSnapshot {
        BtClockSnapshot { ptr }
    }
    pub fn as_const(&mut self) -> BtClockSnapshotConst {
      BtClockSnapshotConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_clock_snapshot_borrow_clock_class_const(self.ptr)} }
  }

  pub fn get_value(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_clock_snapshot_get_value(self.ptr) }
  }

  pub unsafe fn get_ns_from_origin(&self, ns_from_origin: *mut i64) -> BtClockSnapshotGetNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_clock_snapshot_get_ns_from_origin(self.ptr, ns_from_origin)).unwrap() }
  }

}
pub struct BtComponentConst {
    ptr: *const bt_component
}
impl BtComponentConst {
    pub fn empty() -> BtComponentConst {
        BtComponentConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component) -> BtComponentConst {
        BtComponentConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_get_class_type(self.ptr)).unwrap() }
  }

  pub fn borrow_class_const(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_borrow_class_const(self.ptr)} }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_get_name(self.ptr)) }
  }

  pub fn get_logging_level(&self) -> BtLoggingLevel {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_get_logging_level(self.ptr)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_put_ref(self.ptr) }
  }

  pub fn is_source_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_source_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_filter_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_filter_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_sink_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_sink_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtComponent {
    ptr: *mut bt_component
}
impl BtComponent {
    pub fn empty() -> BtComponent {
        BtComponent { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component) -> BtComponent {
        BtComponent { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentConst {
      BtComponentConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_get_class_type(self.ptr)).unwrap() }
  }

  pub fn borrow_class_const(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_borrow_class_const(self.ptr)} }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_get_name(self.ptr)) }
  }

  pub fn get_logging_level(&self) -> BtLoggingLevel {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_get_logging_level(self.ptr)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_put_ref(self.ptr) }
  }

  pub fn is_source_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_source_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_filter_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_filter_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_sink_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_is_sink_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtComponentClassConst {
    ptr: *const bt_component_class
}
impl BtComponentClassConst {
    pub fn empty() -> BtComponentClassConst {
        BtComponentClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_class) -> BtComponentClassConst {
        BtComponentClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_get_type(self.ptr)).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_name(self.ptr)) }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_description(self.ptr)) }
  }

  pub fn get_help(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_help(self.ptr)) }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_put_ref(self.ptr) }
  }

  pub fn is_source_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_source_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_filter_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_filter_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_sink_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_sink_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtComponentClass {
    ptr: *mut bt_component_class
}
impl BtComponentClass {
    pub fn empty() -> BtComponentClass {
        BtComponentClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_class) -> BtComponentClass {
        BtComponentClass { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentClassConst {
      BtComponentClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_get_type(self.ptr)).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_name(self.ptr)) }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_description(self.ptr)) }
  }

  pub fn get_help(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_component_class_get_help(self.ptr)) }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_put_ref(self.ptr) }
  }

  pub unsafe fn set_description(&mut self, description: &str) -> BtComponentClassSetDescriptionStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_component_class_set_description(self.ptr, description.as_ptr())).unwrap() }
  }

  pub unsafe fn set_help(&mut self, help_text: &str) -> BtComponentClassSetHelpStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_component_class_set_help(self.ptr, help_text.as_ptr())).unwrap() }
  }

  pub fn is_source_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_source_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_filter_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_filter_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_sink_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_component_class_is_sink_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtComponentClassFilterConst {
    ptr: *const bt_component_class_filter
}
impl BtComponentClassFilterConst {
    pub fn empty() -> BtComponentClassFilterConst {
        BtComponentClassFilterConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_class_filter) -> BtComponentClassFilterConst {
        BtComponentClassFilterConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_filter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_filter_put_ref(self.ptr) }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_filter_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentClassFilter {
    ptr: *mut bt_component_class_filter
}
impl BtComponentClassFilter {
    pub fn empty() -> BtComponentClassFilter {
        BtComponentClassFilter { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_class_filter) -> BtComponentClassFilter {
        BtComponentClassFilter { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentClassFilterConst {
      BtComponentClassFilterConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_filter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_filter_put_ref(self.ptr) }
  }

  pub unsafe fn create(name: &str, message_iterator_class: &BtMessageIteratorClass) -> BtComponentClassFilter {
    unsafe { BtComponentClassFilter{ ptr:bt_component_class_filter_create(name.as_ptr(), message_iterator_class.ptr)} }
  }

  pub fn set_finalize_method(&mut self, method: bt_component_class_filter_finalize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_finalize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_get_supported_mip_versions_method(&mut self, method: bt_component_class_filter_get_supported_mip_versions_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_get_supported_mip_versions_method(self.ptr, method)).unwrap() }
  }

  pub fn set_initialize_method(&mut self, method: bt_component_class_filter_initialize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_initialize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_input_port_connected_method(&mut self, method: bt_component_class_filter_input_port_connected_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_input_port_connected_method(self.ptr, method)).unwrap() }
  }

  pub fn set_output_port_connected_method(&mut self, method: bt_component_class_filter_output_port_connected_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_output_port_connected_method(self.ptr, method)).unwrap() }
  }

  pub fn set_query_method(&mut self, method: bt_component_class_filter_query_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_filter_set_query_method(self.ptr, method)).unwrap() }
  }

  pub fn as_component_class_inline(&mut self) -> BtComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClass{ ptr:bt_component_class_filter_as_component_class_inline(self.ptr)} }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_filter_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentClassSinkConst {
    ptr: *const bt_component_class_sink
}
impl BtComponentClassSinkConst {
    pub fn empty() -> BtComponentClassSinkConst {
        BtComponentClassSinkConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_class_sink) -> BtComponentClassSinkConst {
        BtComponentClassSinkConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_sink_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_sink_put_ref(self.ptr) }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_sink_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentClassSink {
    ptr: *mut bt_component_class_sink
}
impl BtComponentClassSink {
    pub fn empty() -> BtComponentClassSink {
        BtComponentClassSink { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_class_sink) -> BtComponentClassSink {
        BtComponentClassSink { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentClassSinkConst {
      BtComponentClassSinkConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_sink_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_sink_put_ref(self.ptr) }
  }

  pub unsafe fn create(name: &str, consume_method: bt_component_class_sink_consume_method) -> BtComponentClassSink {
    unsafe { BtComponentClassSink{ ptr:bt_component_class_sink_create(name.as_ptr(), consume_method)} }
  }

  pub fn set_finalize_method(&mut self, method: bt_component_class_sink_finalize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_finalize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_get_supported_mip_versions_method(&mut self, method: bt_component_class_sink_get_supported_mip_versions_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_get_supported_mip_versions_method(self.ptr, method)).unwrap() }
  }

  pub fn set_graph_is_configured_method(&mut self, method: bt_component_class_sink_graph_is_configured_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_graph_is_configured_method(self.ptr, method)).unwrap() }
  }

  pub fn set_initialize_method(&mut self, method: bt_component_class_sink_initialize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_initialize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_input_port_connected_method(&mut self, method: bt_component_class_sink_input_port_connected_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_input_port_connected_method(self.ptr, method)).unwrap() }
  }

  pub fn set_query_method(&mut self, method: bt_component_class_sink_query_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_sink_set_query_method(self.ptr, method)).unwrap() }
  }

  pub fn as_component_class_inline(&mut self) -> BtComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClass{ ptr:bt_component_class_sink_as_component_class_inline(self.ptr)} }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_sink_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentClassSourceConst {
    ptr: *const bt_component_class_source
}
impl BtComponentClassSourceConst {
    pub fn empty() -> BtComponentClassSourceConst {
        BtComponentClassSourceConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_class_source) -> BtComponentClassSourceConst {
        BtComponentClassSourceConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_source_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_source_put_ref(self.ptr) }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_source_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentClassSource {
    ptr: *mut bt_component_class_source
}
impl BtComponentClassSource {
    pub fn empty() -> BtComponentClassSource {
        BtComponentClassSource { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_class_source) -> BtComponentClassSource {
        BtComponentClassSource { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentClassSourceConst {
      BtComponentClassSourceConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_source_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_class_source_put_ref(self.ptr) }
  }

  pub unsafe fn create(name: &str, message_iterator_class: &BtMessageIteratorClass) -> BtComponentClassSource {
    unsafe { BtComponentClassSource{ ptr:bt_component_class_source_create(name.as_ptr(), message_iterator_class.ptr)} }
  }

  pub fn set_finalize_method(&mut self, method: bt_component_class_source_finalize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_source_set_finalize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_get_supported_mip_versions_method(&mut self, method: bt_component_class_source_get_supported_mip_versions_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_source_set_get_supported_mip_versions_method(self.ptr, method)).unwrap() }
  }

  pub fn set_initialize_method(&mut self, method: bt_component_class_source_initialize_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_source_set_initialize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_output_port_connected_method(&mut self, method: bt_component_class_source_output_port_connected_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_source_set_output_port_connected_method(self.ptr, method)).unwrap() }
  }

  pub fn set_query_method(&mut self, method: bt_component_class_source_query_method) -> BtComponentClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_component_class_source_set_query_method(self.ptr, method)).unwrap() }
  }

  pub fn as_component_class_inline(&mut self) -> BtComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClass{ ptr:bt_component_class_source_as_component_class_inline(self.ptr)} }
  }

  pub fn as_component_class_const_inline(&self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_component_class_source_as_component_class_const_inline(self.ptr)} }
  }

}
pub struct BtComponentDescriptorSetConst {
    ptr: *const bt_component_descriptor_set
}
impl BtComponentDescriptorSetConst {
    pub fn empty() -> BtComponentDescriptorSetConst {
        BtComponentDescriptorSetConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_descriptor_set) -> BtComponentDescriptorSetConst {
        BtComponentDescriptorSetConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_descriptor_set_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_descriptor_set_put_ref(self.ptr) }
  }

}
pub struct BtComponentDescriptorSet {
    ptr: *mut bt_component_descriptor_set
}
impl BtComponentDescriptorSet {
    pub fn empty() -> BtComponentDescriptorSet {
        BtComponentDescriptorSet { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_descriptor_set) -> BtComponentDescriptorSet {
        BtComponentDescriptorSet { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentDescriptorSetConst {
      BtComponentDescriptorSetConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create() -> BtComponentDescriptorSet {
    unsafe { BtComponentDescriptorSet{ ptr:bt_component_descriptor_set_create()} }
  }

  pub unsafe fn add_descriptor(&mut self, component_class: &BtComponentClassConst, params: &BtValueConst) -> BtComponentDescriptorSetAddDescriptorStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_component_descriptor_set_add_descriptor(self.ptr, component_class.ptr, params.ptr)).unwrap() }
  }

  pub unsafe fn add_descriptor_with_initialize_method_data(&mut self, component_class: &BtComponentClassConst, params: &BtValueConst, initialize_method_data: *mut ::std::os::raw::c_void) -> BtComponentDescriptorSetAddDescriptorStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_component_descriptor_set_add_descriptor_with_initialize_method_data(self.ptr, component_class.ptr, params.ptr, initialize_method_data)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_descriptor_set_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_descriptor_set_put_ref(self.ptr) }
  }

}
pub struct BtComponentFilterConst {
    ptr: *const bt_component_filter
}
impl BtComponentFilterConst {
    pub fn empty() -> BtComponentFilterConst {
        BtComponentFilterConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_filter) -> BtComponentFilterConst {
        BtComponentFilterConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_component_filter_borrow_class_const(self.ptr)} }
  }

  pub fn get_input_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_input_port_count(self.ptr) }
  }

  pub fn borrow_input_port_by_index_const(&self, index: u64) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_filter_borrow_input_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name_const(&self, name: &str) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_filter_borrow_input_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_output_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_output_port_count(self.ptr) }
  }

  pub fn borrow_output_port_by_index_const(&self, index: u64) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_filter_borrow_output_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_output_port_by_name_const(&self, name: &str) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_filter_borrow_output_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_filter_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtComponentFilter {
    ptr: *mut bt_component_filter
}
impl BtComponentFilter {
    pub fn empty() -> BtComponentFilter {
        BtComponentFilter { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_filter) -> BtComponentFilter {
        BtComponentFilter { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentFilterConst {
      BtComponentFilterConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_component_filter_borrow_class_const(self.ptr)} }
  }

  pub fn get_input_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_input_port_count(self.ptr) }
  }

  pub fn borrow_input_port_by_index_const(&self, index: u64) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_filter_borrow_input_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name_const(&self, name: &str) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_filter_borrow_input_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_output_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_output_port_count(self.ptr) }
  }

  pub fn borrow_output_port_by_index_const(&self, index: u64) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_filter_borrow_output_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_output_port_by_name_const(&self, name: &str) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_filter_borrow_output_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_filter_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_filter_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtComponentSinkConst {
    ptr: *const bt_component_sink
}
impl BtComponentSinkConst {
    pub fn empty() -> BtComponentSinkConst {
        BtComponentSinkConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_sink) -> BtComponentSinkConst {
        BtComponentSinkConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_component_sink_borrow_class_const(self.ptr)} }
  }

  pub fn get_input_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_get_input_port_count(self.ptr) }
  }

  pub fn borrow_input_port_by_index_const(&self, index: u64) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_sink_borrow_input_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name_const(&self, name: &str) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_sink_borrow_input_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_sink_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtComponentSink {
    ptr: *mut bt_component_sink
}
impl BtComponentSink {
    pub fn empty() -> BtComponentSink {
        BtComponentSink { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_sink) -> BtComponentSink {
        BtComponentSink { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentSinkConst {
      BtComponentSinkConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_component_sink_borrow_class_const(self.ptr)} }
  }

  pub fn get_input_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_get_input_port_count(self.ptr) }
  }

  pub fn borrow_input_port_by_index_const(&self, index: u64) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_sink_borrow_input_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name_const(&self, name: &str) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_component_sink_borrow_input_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_sink_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_sink_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtComponentSourceConst {
    ptr: *const bt_component_source
}
impl BtComponentSourceConst {
    pub fn empty() -> BtComponentSourceConst {
        BtComponentSourceConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_component_source) -> BtComponentSourceConst {
        BtComponentSourceConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_component_source_borrow_class_const(self.ptr)} }
  }

  pub fn get_output_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_get_output_port_count(self.ptr) }
  }

  pub fn borrow_output_port_by_index_const(&self, index: u64) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_source_borrow_output_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_output_port_by_name_const(&self, name: &str) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_source_borrow_output_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_source_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtComponentSource {
    ptr: *mut bt_component_source
}
impl BtComponentSource {
    pub fn empty() -> BtComponentSource {
        BtComponentSource { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_component_source) -> BtComponentSource {
        BtComponentSource { ptr }
    }
    pub fn as_const(&mut self) -> BtComponentSourceConst {
      BtComponentSourceConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_component_source_borrow_class_const(self.ptr)} }
  }

  pub fn get_output_port_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_get_output_port_count(self.ptr) }
  }

  pub fn borrow_output_port_by_index_const(&self, index: u64) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_source_borrow_output_port_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_output_port_by_name_const(&self, name: &str) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_component_source_borrow_output_port_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_component_source_put_ref(self.ptr) }
  }

  pub fn as_component_const_inline(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_component_source_as_component_const_inline(self.ptr)} }
  }

}
pub struct BtConnectionConst {
    ptr: *const bt_connection
}
impl BtConnectionConst {
    pub fn empty() -> BtConnectionConst {
        BtConnectionConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_connection) -> BtConnectionConst {
        BtConnectionConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_downstream_port_const(&self) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_connection_borrow_downstream_port_const(self.ptr)} }
  }

  pub fn borrow_upstream_port_const(&self) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_connection_borrow_upstream_port_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_connection_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_connection_put_ref(self.ptr) }
  }

}
pub struct BtConnection {
    ptr: *mut bt_connection
}
impl BtConnection {
    pub fn empty() -> BtConnection {
        BtConnection { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_connection) -> BtConnection {
        BtConnection { ptr }
    }
    pub fn as_const(&mut self) -> BtConnectionConst {
      BtConnectionConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_downstream_port_const(&self) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_connection_borrow_downstream_port_const(self.ptr)} }
  }

  pub fn borrow_upstream_port_const(&self) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_connection_borrow_upstream_port_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_connection_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_connection_put_ref(self.ptr) }
  }

}
pub struct BtErrorConst {
    ptr: *const bt_error
}
impl BtErrorConst {
    pub fn empty() -> BtErrorConst {
        BtErrorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_error) -> BtErrorConst {
        BtErrorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_cause_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_get_cause_count(self.ptr) }
  }

  pub fn borrow_cause_by_index(&self, index: u64) -> BtErrorCauseConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtErrorCauseConst{ ptr:bt_error_borrow_cause_by_index(self.ptr, index)} }
  }

  pub fn release(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_release(self.ptr) }
  }

}
pub struct BtError {
    ptr: *mut bt_error
}
impl BtError {
    pub fn empty() -> BtError {
        BtError { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_error) -> BtError {
        BtError { ptr }
    }
    pub fn as_const(&mut self) -> BtErrorConst {
      BtErrorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_cause_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_get_cause_count(self.ptr) }
  }

  pub fn borrow_cause_by_index(&self, index: u64) -> BtErrorCauseConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtErrorCauseConst{ ptr:bt_error_borrow_cause_by_index(self.ptr, index)} }
  }

  pub fn release(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_release(self.ptr) }
  }

}
pub struct BtErrorCauseConst {
    ptr: *const bt_error_cause
}
impl BtErrorCauseConst {
    pub fn empty() -> BtErrorCauseConst {
        BtErrorCauseConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_error_cause) -> BtErrorCauseConst {
        BtErrorCauseConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_actor_type(&self) -> BtErrorCauseActorType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_get_actor_type(self.ptr)).unwrap() }
  }

  pub fn get_message(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_message(self.ptr)) }
  }

  pub fn get_module_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_module_name(self.ptr)) }
  }

  pub fn get_file_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_file_name(self.ptr)) }
  }

  pub fn get_line_number(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_cause_get_line_number(self.ptr) }
  }

  pub fn component_actor_get_component_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_component_name(self.ptr)) }
  }

  pub fn component_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_component_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn component_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_component_class_name(self.ptr)) }
  }

  pub fn component_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_plugin_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_output_port_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_output_port_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_message_iterator_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn message_iterator_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_class_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_plugin_name(self.ptr)) }
  }

  pub fn component_class_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_component_class_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn component_class_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_class_actor_get_component_class_name(self.ptr)) }
  }

  pub fn component_class_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_class_actor_get_plugin_name(self.ptr)) }
  }

}
pub struct BtErrorCause {
    ptr: *mut bt_error_cause
}
impl BtErrorCause {
    pub fn empty() -> BtErrorCause {
        BtErrorCause { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_error_cause) -> BtErrorCause {
        BtErrorCause { ptr }
    }
    pub fn as_const(&mut self) -> BtErrorCauseConst {
      BtErrorCauseConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_actor_type(&self) -> BtErrorCauseActorType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_get_actor_type(self.ptr)).unwrap() }
  }

  pub fn get_message(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_message(self.ptr)) }
  }

  pub fn get_module_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_module_name(self.ptr)) }
  }

  pub fn get_file_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_get_file_name(self.ptr)) }
  }

  pub fn get_line_number(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_error_cause_get_line_number(self.ptr) }
  }

  pub fn component_actor_get_component_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_component_name(self.ptr)) }
  }

  pub fn component_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_component_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn component_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_component_class_name(self.ptr)) }
  }

  pub fn component_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_actor_get_plugin_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_output_port_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_output_port_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_message_iterator_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn message_iterator_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_component_class_name(self.ptr)) }
  }

  pub fn message_iterator_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_message_iterator_actor_get_plugin_name(self.ptr)) }
  }

  pub fn component_class_actor_get_component_class_type(&self) -> BtComponentClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_error_cause_component_class_actor_get_component_class_type(self.ptr)).unwrap() }
  }

  pub fn component_class_actor_get_component_class_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_class_actor_get_component_class_name(self.ptr)) }
  }

  pub fn component_class_actor_get_plugin_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_error_cause_component_class_actor_get_plugin_name(self.ptr)) }
  }

}
pub struct BtEventConst {
    ptr: *const bt_event
}
impl BtEventConst {
    pub fn empty() -> BtEventConst {
        BtEventConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_event) -> BtEventConst {
        BtEventConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_event_borrow_class_const(self.ptr)} }
  }

  pub fn borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_event_borrow_stream_const(self.ptr)} }
  }

  pub fn borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_event_borrow_packet_const(self.ptr)} }
  }

  pub fn borrow_payload_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_payload_field_const(self.ptr)} }
  }

  pub fn borrow_specific_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_specific_context_field_const(self.ptr)} }
  }

  pub fn borrow_common_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_common_context_field_const(self.ptr)} }
  }

}
pub struct BtEvent {
    ptr: *mut bt_event
}
impl BtEvent {
    pub fn empty() -> BtEvent {
        BtEvent { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_event) -> BtEvent {
        BtEvent { ptr }
    }
    pub fn as_const(&mut self) -> BtEventConst {
      BtEventConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class(&mut self) -> BtEventClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClass{ ptr:bt_event_borrow_class(self.ptr)} }
  }

  pub fn borrow_class_const(&self) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_event_borrow_class_const(self.ptr)} }
  }

  pub fn borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_event_borrow_stream(self.ptr)} }
  }

  pub fn borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_event_borrow_stream_const(self.ptr)} }
  }

  pub fn borrow_packet(&mut self) -> BtPacket {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacket{ ptr:bt_event_borrow_packet(self.ptr)} }
  }

  pub fn borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_event_borrow_packet_const(self.ptr)} }
  }

  pub fn borrow_payload_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_event_borrow_payload_field(self.ptr)} }
  }

  pub fn borrow_payload_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_payload_field_const(self.ptr)} }
  }

  pub fn borrow_specific_context_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_event_borrow_specific_context_field(self.ptr)} }
  }

  pub fn borrow_specific_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_specific_context_field_const(self.ptr)} }
  }

  pub fn borrow_common_context_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_event_borrow_common_context_field(self.ptr)} }
  }

  pub fn borrow_common_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_event_borrow_common_context_field_const(self.ptr)} }
  }

}
pub struct BtEventClassConst {
    ptr: *const bt_event_class
}
impl BtEventClassConst {
    pub fn empty() -> BtEventClassConst {
        BtEventClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_event_class) -> BtEventClassConst {
        BtEventClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_stream_class_const(&self) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_event_class_borrow_stream_class_const(self.ptr)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_get_id(self.ptr) }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_event_class_get_name(self.ptr)) }
  }

  pub unsafe fn get_log_level(&self, log_level: *mut bt_event_class_log_level) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_event_class_get_log_level(self.ptr, log_level)).unwrap() }
  }

  pub fn get_emf_uri(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_event_class_get_emf_uri(self.ptr)) }
  }

  pub fn borrow_payload_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_event_class_borrow_payload_field_class_const(self.ptr)} }
  }

  pub fn borrow_specific_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_event_class_borrow_specific_context_field_class_const(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_event_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_put_ref(self.ptr) }
  }

}
pub struct BtEventClass {
    ptr: *mut bt_event_class
}
impl BtEventClass {
    pub fn empty() -> BtEventClass {
        BtEventClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_event_class) -> BtEventClass {
        BtEventClass { ptr }
    }
    pub fn as_const(&mut self) -> BtEventClassConst {
      BtEventClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(stream_class: &BtStreamClass) -> BtEventClass {
    unsafe { BtEventClass{ ptr:bt_event_class_create(stream_class.ptr)} }
  }

  pub unsafe fn create_with_id(stream_class: &BtStreamClass, id: u64) -> BtEventClass {
    unsafe { BtEventClass{ ptr:bt_event_class_create_with_id(stream_class.ptr, id)} }
  }

  pub fn borrow_stream_class(&mut self) -> BtStreamClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClass{ ptr:bt_event_class_borrow_stream_class(self.ptr)} }
  }

  pub fn borrow_stream_class_const(&self) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_event_class_borrow_stream_class_const(self.ptr)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_get_id(self.ptr) }
  }

  pub unsafe fn set_name(&mut self, name: &str) -> BtEventClassSetNameStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_event_class_set_name(self.ptr, name.as_ptr())).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_event_class_get_name(self.ptr)) }
  }

  pub fn set_log_level(&mut self, log_level: BtEventClassLogLevel)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_set_log_level(self.ptr, num::ToPrimitive::to_u32(&log_level).unwrap()) }
  }

  pub unsafe fn get_log_level(&self, log_level: *mut bt_event_class_log_level) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_event_class_get_log_level(self.ptr, log_level)).unwrap() }
  }

  pub unsafe fn set_emf_uri(&mut self, emf_uri: &str) -> BtEventClassSetEmfUriStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_event_class_set_emf_uri(self.ptr, emf_uri.as_ptr())).unwrap() }
  }

  pub fn get_emf_uri(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_event_class_get_emf_uri(self.ptr)) }
  }

  pub unsafe fn set_payload_field_class(&mut self, field_class: &BtFieldClass) -> BtEventClassSetFieldClassStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_event_class_set_payload_field_class(self.ptr, field_class.ptr)).unwrap() }
  }

  pub fn borrow_payload_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_event_class_borrow_payload_field_class(self.ptr)} }
  }

  pub fn borrow_payload_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_event_class_borrow_payload_field_class_const(self.ptr)} }
  }

  pub unsafe fn set_specific_context_field_class(&mut self, field_class: &BtFieldClass) -> BtEventClassSetFieldClassStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_event_class_set_specific_context_field_class(self.ptr, field_class.ptr)).unwrap() }
  }

  pub fn borrow_specific_context_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_event_class_borrow_specific_context_field_class(self.ptr)} }
  }

  pub fn borrow_specific_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_event_class_borrow_specific_context_field_class_const(self.ptr)} }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_event_class_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_event_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_event_class_put_ref(self.ptr) }
  }

}
pub struct BtEventHeaderFieldConst {
    ptr: *const bt_event_header_field
}
impl BtEventHeaderFieldConst {
    pub fn empty() -> BtEventHeaderFieldConst {
        BtEventHeaderFieldConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_event_header_field) -> BtEventHeaderFieldConst {
        BtEventHeaderFieldConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtEventHeaderField {
    ptr: *mut bt_event_header_field
}
impl BtEventHeaderField {
    pub fn empty() -> BtEventHeaderField {
        BtEventHeaderField { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_event_header_field) -> BtEventHeaderField {
        BtEventHeaderField { ptr }
    }
    pub fn as_const(&mut self) -> BtEventHeaderFieldConst {
      BtEventHeaderFieldConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtFieldConst {
    ptr: *const bt_field
}
impl BtFieldConst {
    pub fn empty() -> BtFieldConst {
        BtFieldConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field) -> BtFieldConst {
        BtFieldConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_class_type(&self) -> BtFieldClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u64(bt_field_get_class_type(self.ptr)).unwrap() }
  }

  pub fn borrow_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_borrow_class_const(self.ptr)} }
  }

  pub fn bool_get_value(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_field_bool_get_value(self.ptr) as u32) != BT_FALSE }
  }

  pub fn bit_array_get_value_as_integer(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_bit_array_get_value_as_integer(self.ptr) }
  }

  pub fn integer_unsigned_get_value(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_unsigned_get_value(self.ptr) }
  }

  pub fn integer_signed_get_value(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_signed_get_value(self.ptr) }
  }

  pub unsafe fn enumeration_unsigned_get_mapping_labels(&self, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldEnumerationGetMappingLabelsStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_enumeration_unsigned_get_mapping_labels(self.ptr, labels, count)).unwrap() }
  }

  pub unsafe fn enumeration_signed_get_mapping_labels(&self, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldEnumerationGetMappingLabelsStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_enumeration_signed_get_mapping_labels(self.ptr, labels, count)).unwrap() }
  }

  pub fn real_single_precision_get_value(&self) -> f32 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_single_precision_get_value(self.ptr) }
  }

  pub fn real_double_precision_get_value(&self) -> f64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_double_precision_get_value(self.ptr) }
  }

  pub fn string_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_string_get_length(self.ptr) }
  }

  pub fn string_get_value(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_string_get_value(self.ptr)) }
  }

  pub fn array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_array_get_length(self.ptr) }
  }

  pub fn array_borrow_element_field_by_index_const(&self, index: u64) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_array_borrow_element_field_by_index_const(self.ptr, index)} }
  }

  pub fn structure_borrow_member_field_by_index_const(&self, index: u64) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_structure_borrow_member_field_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn structure_borrow_member_field_by_name_const(&self, name: &str) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_structure_borrow_member_field_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn option_borrow_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_option_borrow_field_const(self.ptr)} }
  }

  pub fn variant_borrow_selected_option_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_variant_borrow_selected_option_field_const(self.ptr)} }
  }

  pub fn variant_get_selected_option_index(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_variant_get_selected_option_index(self.ptr) }
  }

  pub fn variant_borrow_selected_option_class_const(&self) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_variant_borrow_selected_option_class_const(self.ptr)} }
  }

  pub fn variant_with_selector_field_integer_unsigned_borrow_selected_option_class_const(&self) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_variant_with_selector_field_integer_unsigned_borrow_selected_option_class_const(self.ptr)} }
  }

  pub fn variant_with_selector_field_integer_signed_borrow_selected_option_class_const(&self) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_variant_with_selector_field_integer_signed_borrow_selected_option_class_const(self.ptr)} }
  }

}
pub struct BtField {
    ptr: *mut bt_field
}
impl BtField {
    pub fn empty() -> BtField {
        BtField { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field) -> BtField {
        BtField { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldConst {
      BtFieldConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_class_type(&self) -> BtFieldClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u64(bt_field_get_class_type(self.ptr)).unwrap() }
  }

  pub fn borrow_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_field_borrow_class(self.ptr)} }
  }

  pub fn borrow_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_borrow_class_const(self.ptr)} }
  }

  pub fn bool_set_value(&mut self, value: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_bool_set_value(self.ptr, if value { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn bool_get_value(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_field_bool_get_value(self.ptr) as u32) != BT_FALSE }
  }

  pub fn bit_array_set_value_as_integer(&mut self, bits: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_bit_array_set_value_as_integer(self.ptr, bits) }
  }

  pub fn bit_array_get_value_as_integer(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_bit_array_get_value_as_integer(self.ptr) }
  }

  pub fn integer_unsigned_set_value(&mut self, value: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_unsigned_set_value(self.ptr, value) }
  }

  pub fn integer_unsigned_get_value(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_unsigned_get_value(self.ptr) }
  }

  pub fn integer_signed_set_value(&mut self, value: i64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_signed_set_value(self.ptr, value) }
  }

  pub fn integer_signed_get_value(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_integer_signed_get_value(self.ptr) }
  }

  pub unsafe fn enumeration_unsigned_get_mapping_labels(&self, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldEnumerationGetMappingLabelsStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_enumeration_unsigned_get_mapping_labels(self.ptr, labels, count)).unwrap() }
  }

  pub unsafe fn enumeration_signed_get_mapping_labels(&self, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldEnumerationGetMappingLabelsStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_enumeration_signed_get_mapping_labels(self.ptr, labels, count)).unwrap() }
  }

  pub fn real_single_precision_set_value(&mut self, value: f32)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_single_precision_set_value(self.ptr, value) }
  }

  pub fn real_single_precision_get_value(&self) -> f32 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_single_precision_get_value(self.ptr) }
  }

  pub fn real_double_precision_set_value(&mut self, value: f64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_double_precision_set_value(self.ptr, value) }
  }

  pub fn real_double_precision_get_value(&self) -> f64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_real_double_precision_get_value(self.ptr) }
  }

  pub unsafe fn string_set_value(&mut self, value: &str) -> BtFieldStringSetValueStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_string_set_value(self.ptr, value.as_ptr())).unwrap() }
  }

  pub fn string_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_string_get_length(self.ptr) }
  }

  pub fn string_get_value(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_string_get_value(self.ptr)) }
  }

  pub unsafe fn string_append(&mut self, value: &str) -> BtFieldStringAppendStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_string_append(self.ptr, value.as_ptr())).unwrap() }
  }

  pub unsafe fn string_append_with_length(&mut self, value: &str, length: u64) -> BtFieldStringAppendStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_string_append_with_length(self.ptr, value.as_ptr(), length)).unwrap() }
  }

  pub fn string_clear(&mut self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_string_clear(self.ptr) }
  }

  pub fn array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_array_get_length(self.ptr) }
  }

  pub fn array_borrow_element_field_by_index(&mut self, index: u64) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_field_array_borrow_element_field_by_index(self.ptr, index)} }
  }

  pub fn array_borrow_element_field_by_index_const(&self, index: u64) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_array_borrow_element_field_by_index_const(self.ptr, index)} }
  }

  pub fn array_dynamic_set_length(&mut self, length: u64) -> BtFieldArrayDynamicSetLengthStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_array_dynamic_set_length(self.ptr, length)).unwrap() }
  }

  pub fn structure_borrow_member_field_by_index(&mut self, index: u64) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_field_structure_borrow_member_field_by_index(self.ptr, index)} }
  }

  pub fn structure_borrow_member_field_by_index_const(&self, index: u64) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_structure_borrow_member_field_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn structure_borrow_member_field_by_name(&mut self, name: &str) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_field_structure_borrow_member_field_by_name(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn structure_borrow_member_field_by_name_const(&self, name: &str) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_structure_borrow_member_field_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn option_set_has_field(&mut self, has_field: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_option_set_has_field(self.ptr, if has_field { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn option_borrow_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_field_option_borrow_field(self.ptr)} }
  }

  pub fn option_borrow_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_option_borrow_field_const(self.ptr)} }
  }

  pub fn variant_select_option_by_index(&mut self, index: u64) -> BtFieldVariantSelectOptionByIndexStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_variant_select_option_by_index(self.ptr, index)).unwrap() }
  }

  pub fn variant_borrow_selected_option_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_field_variant_borrow_selected_option_field(self.ptr)} }
  }

  pub fn variant_borrow_selected_option_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_field_variant_borrow_selected_option_field_const(self.ptr)} }
  }

  pub fn variant_get_selected_option_index(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_variant_get_selected_option_index(self.ptr) }
  }

  pub fn variant_borrow_selected_option_class_const(&self) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_variant_borrow_selected_option_class_const(self.ptr)} }
  }

  pub fn variant_with_selector_field_integer_unsigned_borrow_selected_option_class_const(&self) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_variant_with_selector_field_integer_unsigned_borrow_selected_option_class_const(self.ptr)} }
  }

  pub fn variant_with_selector_field_integer_signed_borrow_selected_option_class_const(&self) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_variant_with_selector_field_integer_signed_borrow_selected_option_class_const(self.ptr)} }
  }

}
pub struct BtFieldClassConst {
    ptr: *const bt_field_class
}
impl BtFieldClassConst {
    pub fn empty() -> BtFieldClassConst {
        BtFieldClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class) -> BtFieldClassConst {
        BtFieldClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtFieldClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u64(bt_field_class_get_type(self.ptr)).unwrap() }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn bit_array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_bit_array_get_length(self.ptr) }
  }

  pub fn integer_get_field_value_range(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_integer_get_field_value_range(self.ptr) }
  }

  pub fn integer_get_preferred_display_base(&self) -> BtFieldClassIntegerPreferredDisplayBase {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_class_integer_get_preferred_display_base(self.ptr)).unwrap() }
  }

  pub fn enumeration_get_mapping_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_enumeration_get_mapping_count(self.ptr) }
  }

  pub fn enumeration_unsigned_borrow_mapping_by_index_const(&self, index: u64) -> BtFieldClassEnumerationUnsignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationUnsignedMappingConst{ ptr:bt_field_class_enumeration_unsigned_borrow_mapping_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn enumeration_unsigned_borrow_mapping_by_label_const(&self, label: &str) -> BtFieldClassEnumerationUnsignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationUnsignedMappingConst{ ptr:bt_field_class_enumeration_unsigned_borrow_mapping_by_label_const(self.ptr, label.as_ptr())} }
  }

  pub unsafe fn enumeration_unsigned_get_mapping_labels_for_value(&self, value: u64, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldClassEnumerationGetMappingLabelsForValueStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_unsigned_get_mapping_labels_for_value(self.ptr, value, labels, count)).unwrap() }
  }

  pub fn enumeration_signed_borrow_mapping_by_index_const(&self, index: u64) -> BtFieldClassEnumerationSignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationSignedMappingConst{ ptr:bt_field_class_enumeration_signed_borrow_mapping_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn enumeration_signed_borrow_mapping_by_label_const(&self, label: &str) -> BtFieldClassEnumerationSignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationSignedMappingConst{ ptr:bt_field_class_enumeration_signed_borrow_mapping_by_label_const(self.ptr, label.as_ptr())} }
  }

  pub unsafe fn enumeration_signed_get_mapping_labels_for_value(&self, value: i64, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldClassEnumerationGetMappingLabelsForValueStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_signed_get_mapping_labels_for_value(self.ptr, value, labels, count)).unwrap() }
  }

  pub fn array_borrow_element_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_array_borrow_element_field_class_const(self.ptr)} }
  }

  pub fn array_static_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_array_static_get_length(self.ptr) }
  }

  pub fn array_dynamic_with_length_field_borrow_length_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_array_dynamic_with_length_field_borrow_length_field_path_const(self.ptr)} }
  }

  pub fn structure_get_member_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_structure_get_member_count(self.ptr) }
  }

  pub fn structure_borrow_member_by_index_const(&self, index: u64) -> BtFieldClassStructureMemberConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMemberConst{ ptr:bt_field_class_structure_borrow_member_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn structure_borrow_member_by_name_const(&self, name: &str) -> BtFieldClassStructureMemberConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMemberConst{ ptr:bt_field_class_structure_borrow_member_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn option_borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_option_borrow_field_class_const(self.ptr)} }
  }

  pub fn option_with_selector_field_borrow_selector_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_option_with_selector_field_borrow_selector_field_path_const(self.ptr)} }
  }

  pub fn option_with_selector_field_bool_selector_is_reversed(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_field_class_option_with_selector_field_bool_selector_is_reversed(self.ptr) as u32) != BT_FALSE }
  }

  pub fn option_with_selector_field_integer_unsigned_borrow_selector_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_option_with_selector_field_integer_unsigned_borrow_selector_ranges_const(self.ptr)} }
  }

  pub fn option_with_selector_field_integer_signed_borrow_selector_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_option_with_selector_field_integer_signed_borrow_selector_ranges_const(self.ptr)} }
  }

  pub fn variant_get_option_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_variant_get_option_count(self.ptr) }
  }

  pub fn variant_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_class_variant_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_class_variant_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn variant_with_selector_field_borrow_selector_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_variant_with_selector_field_borrow_selector_field_path_const(self.ptr)} }
  }

  pub fn variant_with_selector_field_integer_unsigned_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_with_selector_field_integer_unsigned_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn variant_with_selector_field_integer_signed_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_with_selector_field_integer_signed_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_put_ref(self.ptr) }
  }

}
pub struct BtFieldClass {
    ptr: *mut bt_field_class
}
impl BtFieldClass {
    pub fn empty() -> BtFieldClass {
        BtFieldClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class) -> BtFieldClass {
        BtFieldClass { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassConst {
      BtFieldClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtFieldClassType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u64(bt_field_class_get_type(self.ptr)).unwrap() }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_field_class_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn bool_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_bool_create(trace_class.ptr)} }
  }

  pub unsafe fn bit_array_create(trace_class: &BtTraceClass, length: u64) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_bit_array_create(trace_class.ptr, length)} }
  }

  pub fn bit_array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_bit_array_get_length(self.ptr) }
  }

  pub fn integer_set_field_value_range(&mut self, n: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_integer_set_field_value_range(self.ptr, n) }
  }

  pub fn integer_get_field_value_range(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_integer_get_field_value_range(self.ptr) }
  }

  pub fn integer_set_preferred_display_base(&mut self, preferred_display_base: BtFieldClassIntegerPreferredDisplayBase)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_integer_set_preferred_display_base(self.ptr, num::ToPrimitive::to_u32(&preferred_display_base).unwrap()) }
  }

  pub fn integer_get_preferred_display_base(&self) -> BtFieldClassIntegerPreferredDisplayBase {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_class_integer_get_preferred_display_base(self.ptr)).unwrap() }
  }

  pub unsafe fn integer_unsigned_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_integer_unsigned_create(trace_class.ptr)} }
  }

  pub unsafe fn integer_signed_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_integer_signed_create(trace_class.ptr)} }
  }

  pub unsafe fn real_single_precision_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_real_single_precision_create(trace_class.ptr)} }
  }

  pub unsafe fn real_double_precision_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_real_double_precision_create(trace_class.ptr)} }
  }

  pub fn enumeration_get_mapping_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_enumeration_get_mapping_count(self.ptr) }
  }

  pub unsafe fn enumeration_unsigned_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_enumeration_unsigned_create(trace_class.ptr)} }
  }

  pub unsafe fn enumeration_unsigned_add_mapping(&mut self, label: &str, ranges: &BtIntegerRangeSetUnsignedConst) -> BtFieldClassEnumerationAddMappingStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_unsigned_add_mapping(self.ptr, label.as_ptr(), ranges.ptr)).unwrap() }
  }

  pub fn enumeration_unsigned_borrow_mapping_by_index_const(&self, index: u64) -> BtFieldClassEnumerationUnsignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationUnsignedMappingConst{ ptr:bt_field_class_enumeration_unsigned_borrow_mapping_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn enumeration_unsigned_borrow_mapping_by_label_const(&self, label: &str) -> BtFieldClassEnumerationUnsignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationUnsignedMappingConst{ ptr:bt_field_class_enumeration_unsigned_borrow_mapping_by_label_const(self.ptr, label.as_ptr())} }
  }

  pub unsafe fn enumeration_unsigned_get_mapping_labels_for_value(&self, value: u64, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldClassEnumerationGetMappingLabelsForValueStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_unsigned_get_mapping_labels_for_value(self.ptr, value, labels, count)).unwrap() }
  }

  pub unsafe fn enumeration_signed_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_enumeration_signed_create(trace_class.ptr)} }
  }

  pub unsafe fn enumeration_signed_add_mapping(&mut self, label: &str, ranges: &BtIntegerRangeSetSignedConst) -> BtFieldClassEnumerationAddMappingStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_signed_add_mapping(self.ptr, label.as_ptr(), ranges.ptr)).unwrap() }
  }

  pub fn enumeration_signed_borrow_mapping_by_index_const(&self, index: u64) -> BtFieldClassEnumerationSignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationSignedMappingConst{ ptr:bt_field_class_enumeration_signed_borrow_mapping_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn enumeration_signed_borrow_mapping_by_label_const(&self, label: &str) -> BtFieldClassEnumerationSignedMappingConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassEnumerationSignedMappingConst{ ptr:bt_field_class_enumeration_signed_borrow_mapping_by_label_const(self.ptr, label.as_ptr())} }
  }

  pub unsafe fn enumeration_signed_get_mapping_labels_for_value(&self, value: i64, labels: *mut bt_field_class_enumeration_mapping_label_array, count: *mut u64) -> BtFieldClassEnumerationGetMappingLabelsForValueStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_enumeration_signed_get_mapping_labels_for_value(self.ptr, value, labels, count)).unwrap() }
  }

  pub unsafe fn string_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_string_create(trace_class.ptr)} }
  }

  pub fn array_borrow_element_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_field_class_array_borrow_element_field_class(self.ptr)} }
  }

  pub fn array_borrow_element_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_array_borrow_element_field_class_const(self.ptr)} }
  }

  pub unsafe fn array_static_create(trace_class: &BtTraceClass, element_field_class: &BtFieldClass, length: u64) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_array_static_create(trace_class.ptr, element_field_class.ptr, length)} }
  }

  pub fn array_static_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_array_static_get_length(self.ptr) }
  }

  pub unsafe fn array_dynamic_create(trace_class: &BtTraceClass, element_field_class: &BtFieldClass, length_field_class: &BtFieldClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_array_dynamic_create(trace_class.ptr, element_field_class.ptr, length_field_class.ptr)} }
  }

  pub fn array_dynamic_with_length_field_borrow_length_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_array_dynamic_with_length_field_borrow_length_field_path_const(self.ptr)} }
  }

  pub unsafe fn structure_create(trace_class: &BtTraceClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_structure_create(trace_class.ptr)} }
  }

  pub unsafe fn structure_append_member(&mut self, name: &str, member_field_class: &BtFieldClass) -> BtFieldClassStructureAppendMemberStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_structure_append_member(self.ptr, name.as_ptr(), member_field_class.ptr)).unwrap() }
  }

  pub fn structure_get_member_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_structure_get_member_count(self.ptr) }
  }

  pub fn structure_borrow_member_by_index(&mut self, index: u64) -> BtFieldClassStructureMember {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMember{ ptr:bt_field_class_structure_borrow_member_by_index(self.ptr, index)} }
  }

  pub fn structure_borrow_member_by_index_const(&self, index: u64) -> BtFieldClassStructureMemberConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMemberConst{ ptr:bt_field_class_structure_borrow_member_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn structure_borrow_member_by_name(&mut self, name: &str) -> BtFieldClassStructureMember {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMember{ ptr:bt_field_class_structure_borrow_member_by_name(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn structure_borrow_member_by_name_const(&self, name: &str) -> BtFieldClassStructureMemberConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassStructureMemberConst{ ptr:bt_field_class_structure_borrow_member_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn option_borrow_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_field_class_option_borrow_field_class(self.ptr)} }
  }

  pub fn option_borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_option_borrow_field_class_const(self.ptr)} }
  }

  pub unsafe fn option_without_selector_create(trace_class: &BtTraceClass, optional_field_class: &BtFieldClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_option_without_selector_create(trace_class.ptr, optional_field_class.ptr)} }
  }

  pub fn option_with_selector_field_borrow_selector_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_option_with_selector_field_borrow_selector_field_path_const(self.ptr)} }
  }

  pub unsafe fn option_with_selector_field_bool_create(trace_class: &BtTraceClass, optional_field_class: &BtFieldClass, selector_field_class: &BtFieldClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_option_with_selector_field_bool_create(trace_class.ptr, optional_field_class.ptr, selector_field_class.ptr)} }
  }

  pub fn option_with_selector_field_bool_set_selector_is_reversed(&mut self, selector_is_reversed: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_option_with_selector_field_bool_set_selector_is_reversed(self.ptr, if selector_is_reversed { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn option_with_selector_field_bool_selector_is_reversed(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_field_class_option_with_selector_field_bool_selector_is_reversed(self.ptr) as u32) != BT_FALSE }
  }

  pub unsafe fn option_with_selector_field_integer_unsigned_create(trace_class: &BtTraceClass, optional_field_class: &BtFieldClass, selector_field_class: &BtFieldClass, ranges: &BtIntegerRangeSetUnsignedConst) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_option_with_selector_field_integer_unsigned_create(trace_class.ptr, optional_field_class.ptr, selector_field_class.ptr, ranges.ptr)} }
  }

  pub fn option_with_selector_field_integer_unsigned_borrow_selector_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_option_with_selector_field_integer_unsigned_borrow_selector_ranges_const(self.ptr)} }
  }

  pub unsafe fn option_with_selector_field_integer_signed_create(trace_class: &BtTraceClass, optional_field_class: &BtFieldClass, selector_field_class: &BtFieldClass, ranges: &BtIntegerRangeSetSignedConst) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_option_with_selector_field_integer_signed_create(trace_class.ptr, optional_field_class.ptr, selector_field_class.ptr, ranges.ptr)} }
  }

  pub fn option_with_selector_field_integer_signed_borrow_selector_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_option_with_selector_field_integer_signed_borrow_selector_ranges_const(self.ptr)} }
  }

  pub unsafe fn variant_create(trace_class: &BtTraceClass, selector_field_class: &BtFieldClass) -> BtFieldClass {
    unsafe { BtFieldClass{ ptr:bt_field_class_variant_create(trace_class.ptr, selector_field_class.ptr)} }
  }

  pub fn variant_get_option_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_variant_get_option_count(self.ptr) }
  }

  pub fn variant_borrow_option_by_index(&mut self, index: u64) -> BtFieldClassVariantOption {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOption{ ptr:bt_field_class_variant_borrow_option_by_index(self.ptr, index)} }
  }

  pub fn variant_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_class_variant_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_borrow_option_by_name(&mut self, name: &str) -> BtFieldClassVariantOption {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOption{ ptr:bt_field_class_variant_borrow_option_by_name(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn variant_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantOptionConst{ ptr:bt_field_class_variant_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn variant_without_selector_append_option(&mut self, name: &str, option_field_class: &BtFieldClass) -> BtFieldClassVariantWithoutSelectorAppendOptionStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_variant_without_selector_append_option(self.ptr, name.as_ptr(), option_field_class.ptr)).unwrap() }
  }

  pub fn variant_with_selector_field_borrow_selector_field_path_const(&self) -> BtFieldPathConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathConst{ ptr:bt_field_class_variant_with_selector_field_borrow_selector_field_path_const(self.ptr)} }
  }

  pub unsafe fn variant_with_selector_field_integer_unsigned_append_option(&mut self, name: &str, option_field_class: &BtFieldClass, ranges: &BtIntegerRangeSetUnsignedConst) -> BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_variant_with_selector_field_integer_unsigned_append_option(self.ptr, name.as_ptr(), option_field_class.ptr, ranges.ptr)).unwrap() }
  }

  pub fn variant_with_selector_field_integer_unsigned_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_with_selector_field_integer_unsigned_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn variant_with_selector_field_integer_signed_append_option(&mut self, name: &str, option_field_class: &BtFieldClass, ranges: &BtIntegerRangeSetSignedConst) -> BtFieldClassVariantWithSelectorFieldIntegerAppendOptionStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_field_class_variant_with_selector_field_integer_signed_append_option(self.ptr, name.as_ptr(), option_field_class.ptr, ranges.ptr)).unwrap() }
  }

  pub fn variant_with_selector_field_integer_signed_borrow_option_by_index_const(&self, index: u64) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn variant_with_selector_field_integer_signed_borrow_option_by_name_const(&self, name: &str) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_borrow_option_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_put_ref(self.ptr) }
  }

}
pub struct BtFieldClassEnumerationMappingConst {
    ptr: *const bt_field_class_enumeration_mapping
}
impl BtFieldClassEnumerationMappingConst {
    pub fn empty() -> BtFieldClassEnumerationMappingConst {
        BtFieldClassEnumerationMappingConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_enumeration_mapping) -> BtFieldClassEnumerationMappingConst {
        BtFieldClassEnumerationMappingConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_label(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_enumeration_mapping_get_label(self.ptr)) }
  }

}
pub struct BtFieldClassEnumerationMapping {
    ptr: *mut bt_field_class_enumeration_mapping
}
impl BtFieldClassEnumerationMapping {
    pub fn empty() -> BtFieldClassEnumerationMapping {
        BtFieldClassEnumerationMapping { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_enumeration_mapping) -> BtFieldClassEnumerationMapping {
        BtFieldClassEnumerationMapping { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassEnumerationMappingConst {
      BtFieldClassEnumerationMappingConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_label(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_enumeration_mapping_get_label(self.ptr)) }
  }

}
pub struct BtFieldClassEnumerationSignedMappingConst {
    ptr: *const bt_field_class_enumeration_signed_mapping
}
impl BtFieldClassEnumerationSignedMappingConst {
    pub fn empty() -> BtFieldClassEnumerationSignedMappingConst {
        BtFieldClassEnumerationSignedMappingConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_enumeration_signed_mapping) -> BtFieldClassEnumerationSignedMappingConst {
        BtFieldClassEnumerationSignedMappingConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_enumeration_signed_mapping_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassEnumerationSignedMapping {
    ptr: *mut bt_field_class_enumeration_signed_mapping
}
impl BtFieldClassEnumerationSignedMapping {
    pub fn empty() -> BtFieldClassEnumerationSignedMapping {
        BtFieldClassEnumerationSignedMapping { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_enumeration_signed_mapping) -> BtFieldClassEnumerationSignedMapping {
        BtFieldClassEnumerationSignedMapping { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassEnumerationSignedMappingConst {
      BtFieldClassEnumerationSignedMappingConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_enumeration_signed_mapping_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassEnumerationUnsignedMappingConst {
    ptr: *const bt_field_class_enumeration_unsigned_mapping
}
impl BtFieldClassEnumerationUnsignedMappingConst {
    pub fn empty() -> BtFieldClassEnumerationUnsignedMappingConst {
        BtFieldClassEnumerationUnsignedMappingConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_enumeration_unsigned_mapping) -> BtFieldClassEnumerationUnsignedMappingConst {
        BtFieldClassEnumerationUnsignedMappingConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_enumeration_unsigned_mapping_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassEnumerationUnsignedMapping {
    ptr: *mut bt_field_class_enumeration_unsigned_mapping
}
impl BtFieldClassEnumerationUnsignedMapping {
    pub fn empty() -> BtFieldClassEnumerationUnsignedMapping {
        BtFieldClassEnumerationUnsignedMapping { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_enumeration_unsigned_mapping) -> BtFieldClassEnumerationUnsignedMapping {
        BtFieldClassEnumerationUnsignedMapping { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassEnumerationUnsignedMappingConst {
      BtFieldClassEnumerationUnsignedMappingConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_enumeration_unsigned_mapping_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassStructureMemberConst {
    ptr: *const bt_field_class_structure_member
}
impl BtFieldClassStructureMemberConst {
    pub fn empty() -> BtFieldClassStructureMemberConst {
        BtFieldClassStructureMemberConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_structure_member) -> BtFieldClassStructureMemberConst {
        BtFieldClassStructureMemberConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_structure_member_get_name(self.ptr)) }
  }

  pub fn borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_structure_member_borrow_field_class_const(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_structure_member_borrow_user_attributes_const(self.ptr)} }
  }

}
pub struct BtFieldClassStructureMember {
    ptr: *mut bt_field_class_structure_member
}
impl BtFieldClassStructureMember {
    pub fn empty() -> BtFieldClassStructureMember {
        BtFieldClassStructureMember { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_structure_member) -> BtFieldClassStructureMember {
        BtFieldClassStructureMember { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassStructureMemberConst {
      BtFieldClassStructureMemberConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_structure_member_get_name(self.ptr)) }
  }

  pub fn borrow_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_field_class_structure_member_borrow_field_class(self.ptr)} }
  }

  pub fn borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_structure_member_borrow_field_class_const(self.ptr)} }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_structure_member_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_field_class_structure_member_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_structure_member_borrow_user_attributes_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantOptionConst {
    ptr: *const bt_field_class_variant_option
}
impl BtFieldClassVariantOptionConst {
    pub fn empty() -> BtFieldClassVariantOptionConst {
        BtFieldClassVariantOptionConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_variant_option) -> BtFieldClassVariantOptionConst {
        BtFieldClassVariantOptionConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_variant_option_get_name(self.ptr)) }
  }

  pub fn borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_variant_option_borrow_field_class_const(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_variant_option_borrow_user_attributes_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantOption {
    ptr: *mut bt_field_class_variant_option
}
impl BtFieldClassVariantOption {
    pub fn empty() -> BtFieldClassVariantOption {
        BtFieldClassVariantOption { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_variant_option) -> BtFieldClassVariantOption {
        BtFieldClassVariantOption { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassVariantOptionConst {
      BtFieldClassVariantOptionConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_field_class_variant_option_get_name(self.ptr)) }
  }

  pub fn borrow_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_field_class_variant_option_borrow_field_class(self.ptr)} }
  }

  pub fn borrow_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_field_class_variant_option_borrow_field_class_const(self.ptr)} }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_class_variant_option_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_field_class_variant_option_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_field_class_variant_option_borrow_user_attributes_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    ptr: *const bt_field_class_variant_with_selector_field_integer_signed_option
}
impl BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
    pub fn empty() -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
        BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_variant_with_selector_field_integer_signed_option) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
        BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_option_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantWithSelectorFieldIntegerSignedOption {
    ptr: *mut bt_field_class_variant_with_selector_field_integer_signed_option
}
impl BtFieldClassVariantWithSelectorFieldIntegerSignedOption {
    pub fn empty() -> BtFieldClassVariantWithSelectorFieldIntegerSignedOption {
        BtFieldClassVariantWithSelectorFieldIntegerSignedOption { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_variant_with_selector_field_integer_signed_option) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOption {
        BtFieldClassVariantWithSelectorFieldIntegerSignedOption { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst {
      BtFieldClassVariantWithSelectorFieldIntegerSignedOptionConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetSignedConst{ ptr:bt_field_class_variant_with_selector_field_integer_signed_option_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    ptr: *const bt_field_class_variant_with_selector_field_integer_unsigned_option
}
impl BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
    pub fn empty() -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
        BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_class_variant_with_selector_field_integer_unsigned_option) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
        BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_option_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption {
    ptr: *mut bt_field_class_variant_with_selector_field_integer_unsigned_option
}
impl BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption {
    pub fn empty() -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption {
        BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_class_variant_with_selector_field_integer_unsigned_option) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption {
        BtFieldClassVariantWithSelectorFieldIntegerUnsignedOption { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst {
      BtFieldClassVariantWithSelectorFieldIntegerUnsignedOptionConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_ranges_const(&self) -> BtIntegerRangeSetUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSetUnsignedConst{ ptr:bt_field_class_variant_with_selector_field_integer_unsigned_option_borrow_ranges_const(self.ptr)} }
  }

}
pub struct BtFieldPathConst {
    ptr: *const bt_field_path
}
impl BtFieldPathConst {
    pub fn empty() -> BtFieldPathConst {
        BtFieldPathConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_path) -> BtFieldPathConst {
        BtFieldPathConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_root_scope(&self) -> BtFieldPathScope {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_path_get_root_scope(self.ptr)).unwrap() }
  }

  pub fn get_item_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_get_item_count(self.ptr) }
  }

  pub fn borrow_item_by_index_const(&self, index: u64) -> BtFieldPathItemConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathItemConst{ ptr:bt_field_path_borrow_item_by_index_const(self.ptr, index)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_put_ref(self.ptr) }
  }

}
pub struct BtFieldPath {
    ptr: *mut bt_field_path
}
impl BtFieldPath {
    pub fn empty() -> BtFieldPath {
        BtFieldPath { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_path) -> BtFieldPath {
        BtFieldPath { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldPathConst {
      BtFieldPathConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_root_scope(&self) -> BtFieldPathScope {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_path_get_root_scope(self.ptr)).unwrap() }
  }

  pub fn get_item_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_get_item_count(self.ptr) }
  }

  pub fn borrow_item_by_index_const(&self, index: u64) -> BtFieldPathItemConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldPathItemConst{ ptr:bt_field_path_borrow_item_by_index_const(self.ptr, index)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_put_ref(self.ptr) }
  }

}
pub struct BtFieldPathItemConst {
    ptr: *const bt_field_path_item
}
impl BtFieldPathItemConst {
    pub fn empty() -> BtFieldPathItemConst {
        BtFieldPathItemConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_field_path_item) -> BtFieldPathItemConst {
        BtFieldPathItemConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtFieldPathItemType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_path_item_get_type(self.ptr)).unwrap() }
  }

  pub fn index_get_index(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_item_index_get_index(self.ptr) }
  }

}
pub struct BtFieldPathItem {
    ptr: *mut bt_field_path_item
}
impl BtFieldPathItem {
    pub fn empty() -> BtFieldPathItem {
        BtFieldPathItem { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_field_path_item) -> BtFieldPathItem {
        BtFieldPathItem { ptr }
    }
    pub fn as_const(&mut self) -> BtFieldPathItemConst {
      BtFieldPathItemConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtFieldPathItemType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_field_path_item_get_type(self.ptr)).unwrap() }
  }

  pub fn index_get_index(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_field_path_item_index_get_index(self.ptr) }
  }

}
pub struct BtGraphConst {
    ptr: *const bt_graph
}
impl BtGraphConst {
    pub fn empty() -> BtGraphConst {
        BtGraphConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_graph) -> BtGraphConst {
        BtGraphConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_graph_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_graph_put_ref(self.ptr) }
  }

}
pub struct BtGraph {
    ptr: *mut bt_graph
}
impl BtGraph {
    pub fn empty() -> BtGraph {
        BtGraph { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_graph) -> BtGraph {
        BtGraph { ptr }
    }
    pub fn as_const(&mut self) -> BtGraphConst {
      BtGraphConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create(mip_version: u64) -> BtGraph {
    unsafe { BtGraph{ ptr:bt_graph_create(mip_version)} }
  }

  pub unsafe fn add_source_component(&mut self, component_class: &BtComponentClassSourceConst, name: &str, params: &BtValueConst, logging_level: BtLoggingLevel, component: *mut *const bt_component_source) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_source_component(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_source_component_with_initialize_method_data(&mut self, component_class: &BtComponentClassSourceConst, name: &str, params: &BtValueConst, initialize_method_data: *mut ::std::os::raw::c_void, logging_level: BtLoggingLevel, component: *mut *const bt_component_source) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_source_component_with_initialize_method_data(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, initialize_method_data, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_filter_component(&mut self, component_class: &BtComponentClassFilterConst, name: &str, params: &BtValueConst, logging_level: BtLoggingLevel, component: *mut *const bt_component_filter) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_filter_component(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_filter_component_with_initialize_method_data(&mut self, component_class: &BtComponentClassFilterConst, name: &str, params: &BtValueConst, initialize_method_data: *mut ::std::os::raw::c_void, logging_level: BtLoggingLevel, component: *mut *const bt_component_filter) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_filter_component_with_initialize_method_data(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, initialize_method_data, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_sink_component(&mut self, component_class: &BtComponentClassSinkConst, name: &str, params: &BtValueConst, logging_level: BtLoggingLevel, component: *mut *const bt_component_sink) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_sink_component(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_sink_component_with_initialize_method_data(&mut self, component_class: &BtComponentClassSinkConst, name: &str, params: &BtValueConst, initialize_method_data: *mut ::std::os::raw::c_void, logging_level: BtLoggingLevel, component: *mut *const bt_component_sink) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_sink_component_with_initialize_method_data(self.ptr, component_class.ptr, name.as_ptr(), params.ptr, initialize_method_data, num::ToPrimitive::to_u32(&logging_level).unwrap(), component)).unwrap() }
  }

  pub unsafe fn add_simple_sink_component(&mut self, name: &str, initialize_func: bt_graph_simple_sink_component_initialize_func, consume_func: bt_graph_simple_sink_component_consume_func, finalize_func: bt_graph_simple_sink_component_finalize_func, user_data: *mut ::std::os::raw::c_void, component: *mut *const bt_component_sink) -> BtGraphAddComponentStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_simple_sink_component(self.ptr, name.as_ptr(), initialize_func, consume_func, finalize_func, user_data, component)).unwrap() }
  }

  pub unsafe fn connect_ports(&mut self, upstream_port: &BtPortOutputConst, downstream_port: &BtPortInputConst, connection: *mut *const bt_connection) -> BtGraphConnectPortsStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_connect_ports(self.ptr, upstream_port.ptr, downstream_port.ptr, connection)).unwrap() }
  }

  pub fn run(&mut self) -> BtGraphRunStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_run(self.ptr)).unwrap() }
  }

  pub fn run_once(&mut self) -> BtGraphRunOnceStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_run_once(self.ptr)).unwrap() }
  }

  pub unsafe fn add_interrupter(&mut self, interrupter: &BtInterrupterConst) -> BtGraphAddInterrupterStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_interrupter(self.ptr, interrupter.ptr)).unwrap() }
  }

  pub fn borrow_default_interrupter(&mut self) -> BtInterrupter {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtInterrupter{ ptr:bt_graph_borrow_default_interrupter(self.ptr)} }
  }

  pub unsafe fn add_filter_component_input_port_added_listener(&mut self, user_func: bt_graph_filter_component_input_port_added_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtGraphAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_filter_component_input_port_added_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub unsafe fn add_sink_component_input_port_added_listener(&mut self, user_func: bt_graph_sink_component_input_port_added_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtGraphAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_sink_component_input_port_added_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub unsafe fn add_source_component_output_port_added_listener(&mut self, user_func: bt_graph_source_component_output_port_added_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtGraphAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_source_component_output_port_added_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub unsafe fn add_filter_component_output_port_added_listener(&mut self, user_func: bt_graph_filter_component_output_port_added_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtGraphAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_graph_add_filter_component_output_port_added_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_graph_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_graph_put_ref(self.ptr) }
  }

}
pub struct BtIntegerRangeSetConst {
    ptr: *const bt_integer_range_set
}
impl BtIntegerRangeSetConst {
    pub fn empty() -> BtIntegerRangeSetConst {
        BtIntegerRangeSetConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_integer_range_set) -> BtIntegerRangeSetConst {
        BtIntegerRangeSetConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_range_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_get_range_count(self.ptr) }
  }

}
pub struct BtIntegerRangeSet {
    ptr: *mut bt_integer_range_set
}
impl BtIntegerRangeSet {
    pub fn empty() -> BtIntegerRangeSet {
        BtIntegerRangeSet { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_integer_range_set) -> BtIntegerRangeSet {
        BtIntegerRangeSet { ptr }
    }
    pub fn as_const(&mut self) -> BtIntegerRangeSetConst {
      BtIntegerRangeSetConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_range_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_get_range_count(self.ptr) }
  }

}
pub struct BtIntegerRangeSetSignedConst {
    ptr: *const bt_integer_range_set_signed
}
impl BtIntegerRangeSetSignedConst {
    pub fn empty() -> BtIntegerRangeSetSignedConst {
        BtIntegerRangeSetSignedConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_integer_range_set_signed) -> BtIntegerRangeSetSignedConst {
        BtIntegerRangeSetSignedConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_range_by_index_const(&self, index: u64) -> BtIntegerRangeSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSignedConst{ ptr:bt_integer_range_set_signed_borrow_range_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn is_equal(&self, int_range_set_b: &BtIntegerRangeSetSignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_set_signed_is_equal(self.ptr, int_range_set_b.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_signed_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_signed_put_ref(self.ptr) }
  }

}
pub struct BtIntegerRangeSetSigned {
    ptr: *mut bt_integer_range_set_signed
}
impl BtIntegerRangeSetSigned {
    pub fn empty() -> BtIntegerRangeSetSigned {
        BtIntegerRangeSetSigned { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_integer_range_set_signed) -> BtIntegerRangeSetSigned {
        BtIntegerRangeSetSigned { ptr }
    }
    pub fn as_const(&mut self) -> BtIntegerRangeSetSignedConst {
      BtIntegerRangeSetSignedConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create() -> BtIntegerRangeSetSigned {
    unsafe { BtIntegerRangeSetSigned{ ptr:bt_integer_range_set_signed_create()} }
  }

  pub fn add_range(&mut self, lower: i64, upper: i64) -> BtIntegerRangeSetAddRangeStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_integer_range_set_signed_add_range(self.ptr, lower, upper)).unwrap() }
  }

  pub fn borrow_range_by_index_const(&self, index: u64) -> BtIntegerRangeSignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeSignedConst{ ptr:bt_integer_range_set_signed_borrow_range_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn is_equal(&self, int_range_set_b: &BtIntegerRangeSetSignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_set_signed_is_equal(self.ptr, int_range_set_b.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_signed_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_signed_put_ref(self.ptr) }
  }

}
pub struct BtIntegerRangeSetUnsignedConst {
    ptr: *const bt_integer_range_set_unsigned
}
impl BtIntegerRangeSetUnsignedConst {
    pub fn empty() -> BtIntegerRangeSetUnsignedConst {
        BtIntegerRangeSetUnsignedConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_integer_range_set_unsigned) -> BtIntegerRangeSetUnsignedConst {
        BtIntegerRangeSetUnsignedConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_range_by_index_const(&self, index: u64) -> BtIntegerRangeUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeUnsignedConst{ ptr:bt_integer_range_set_unsigned_borrow_range_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn is_equal(&self, int_range_set_b: &BtIntegerRangeSetUnsignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_set_unsigned_is_equal(self.ptr, int_range_set_b.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_unsigned_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_unsigned_put_ref(self.ptr) }
  }

}
pub struct BtIntegerRangeSetUnsigned {
    ptr: *mut bt_integer_range_set_unsigned
}
impl BtIntegerRangeSetUnsigned {
    pub fn empty() -> BtIntegerRangeSetUnsigned {
        BtIntegerRangeSetUnsigned { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_integer_range_set_unsigned) -> BtIntegerRangeSetUnsigned {
        BtIntegerRangeSetUnsigned { ptr }
    }
    pub fn as_const(&mut self) -> BtIntegerRangeSetUnsignedConst {
      BtIntegerRangeSetUnsignedConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create() -> BtIntegerRangeSetUnsigned {
    unsafe { BtIntegerRangeSetUnsigned{ ptr:bt_integer_range_set_unsigned_create()} }
  }

  pub fn add_range(&mut self, lower: u64, upper: u64) -> BtIntegerRangeSetAddRangeStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_integer_range_set_unsigned_add_range(self.ptr, lower, upper)).unwrap() }
  }

  pub fn borrow_range_by_index_const(&self, index: u64) -> BtIntegerRangeUnsignedConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtIntegerRangeUnsignedConst{ ptr:bt_integer_range_set_unsigned_borrow_range_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn is_equal(&self, int_range_set_b: &BtIntegerRangeSetUnsignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_set_unsigned_is_equal(self.ptr, int_range_set_b.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_unsigned_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_set_unsigned_put_ref(self.ptr) }
  }

}
pub struct BtIntegerRangeSignedConst {
    ptr: *const bt_integer_range_signed
}
impl BtIntegerRangeSignedConst {
    pub fn empty() -> BtIntegerRangeSignedConst {
        BtIntegerRangeSignedConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_integer_range_signed) -> BtIntegerRangeSignedConst {
        BtIntegerRangeSignedConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_lower(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_signed_get_lower(self.ptr) }
  }

  pub fn get_upper(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_signed_get_upper(self.ptr) }
  }

  pub unsafe fn is_equal(&self, b_int_range: &BtIntegerRangeSignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_signed_is_equal(self.ptr, b_int_range.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtIntegerRangeSigned {
    ptr: *mut bt_integer_range_signed
}
impl BtIntegerRangeSigned {
    pub fn empty() -> BtIntegerRangeSigned {
        BtIntegerRangeSigned { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_integer_range_signed) -> BtIntegerRangeSigned {
        BtIntegerRangeSigned { ptr }
    }
    pub fn as_const(&mut self) -> BtIntegerRangeSignedConst {
      BtIntegerRangeSignedConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_lower(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_signed_get_lower(self.ptr) }
  }

  pub fn get_upper(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_signed_get_upper(self.ptr) }
  }

  pub unsafe fn is_equal(&self, b_int_range: &BtIntegerRangeSignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_signed_is_equal(self.ptr, b_int_range.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtIntegerRangeUnsignedConst {
    ptr: *const bt_integer_range_unsigned
}
impl BtIntegerRangeUnsignedConst {
    pub fn empty() -> BtIntegerRangeUnsignedConst {
        BtIntegerRangeUnsignedConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_integer_range_unsigned) -> BtIntegerRangeUnsignedConst {
        BtIntegerRangeUnsignedConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_lower(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_unsigned_get_lower(self.ptr) }
  }

  pub fn get_upper(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_unsigned_get_upper(self.ptr) }
  }

  pub unsafe fn is_equal(&self, b_int_range: &BtIntegerRangeUnsignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_unsigned_is_equal(self.ptr, b_int_range.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtIntegerRangeUnsigned {
    ptr: *mut bt_integer_range_unsigned
}
impl BtIntegerRangeUnsigned {
    pub fn empty() -> BtIntegerRangeUnsigned {
        BtIntegerRangeUnsigned { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_integer_range_unsigned) -> BtIntegerRangeUnsigned {
        BtIntegerRangeUnsigned { ptr }
    }
    pub fn as_const(&mut self) -> BtIntegerRangeUnsignedConst {
      BtIntegerRangeUnsignedConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_lower(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_unsigned_get_lower(self.ptr) }
  }

  pub fn get_upper(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_integer_range_unsigned_get_upper(self.ptr) }
  }

  pub unsafe fn is_equal(&self, b_int_range: &BtIntegerRangeUnsignedConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_integer_range_unsigned_is_equal(self.ptr, b_int_range.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtInterrupterConst {
    ptr: *const bt_interrupter
}
impl BtInterrupterConst {
    pub fn empty() -> BtInterrupterConst {
        BtInterrupterConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_interrupter) -> BtInterrupterConst {
        BtInterrupterConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn is_set(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_interrupter_is_set(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_put_ref(self.ptr) }
  }

}
pub struct BtInterrupter {
    ptr: *mut bt_interrupter
}
impl BtInterrupter {
    pub fn empty() -> BtInterrupter {
        BtInterrupter { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_interrupter) -> BtInterrupter {
        BtInterrupter { ptr }
    }
    pub fn as_const(&mut self) -> BtInterrupterConst {
      BtInterrupterConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create() -> BtInterrupter {
    unsafe { BtInterrupter{ ptr:bt_interrupter_create()} }
  }

  pub fn set(&mut self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_set(self.ptr) }
  }

  pub fn reset(&mut self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_reset(self.ptr) }
  }

  pub fn is_set(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_interrupter_is_set(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_interrupter_put_ref(self.ptr) }
  }

}
pub struct BtMessageConst {
    ptr: *const bt_message
}
impl BtMessageConst {
    pub fn empty() -> BtMessageConst {
        BtMessageConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_message) -> BtMessageConst {
        BtMessageConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtMessageType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_get_type(self.ptr)).unwrap() }
  }

  pub fn stream_beginning_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_stream_beginning_borrow_stream_const(self.ptr)} }
  }

  pub unsafe fn stream_beginning_borrow_default_clock_snapshot_const(&self, clock_snapshot: *mut *const bt_clock_snapshot) -> BtMessageStreamClockSnapshotState {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_stream_beginning_borrow_default_clock_snapshot_const(self.ptr, clock_snapshot)).unwrap() }
  }

  pub fn stream_beginning_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_stream_beginning_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn stream_end_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_stream_end_borrow_stream_const(self.ptr)} }
  }

  pub unsafe fn stream_end_borrow_default_clock_snapshot_const(&self, clock_snapshot: *mut *const bt_clock_snapshot) -> BtMessageStreamClockSnapshotState {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_stream_end_borrow_default_clock_snapshot_const(self.ptr, clock_snapshot)).unwrap() }
  }

  pub fn stream_end_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_stream_end_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn event_borrow_event_const(&self) -> BtEventConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventConst{ ptr:bt_message_event_borrow_event_const(self.ptr)} }
  }

  pub fn event_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_event_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn event_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_event_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn packet_beginning_borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_message_packet_beginning_borrow_packet_const(self.ptr)} }
  }

  pub fn packet_beginning_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_packet_beginning_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn packet_beginning_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_packet_beginning_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn packet_end_borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_message_packet_end_borrow_packet_const(self.ptr)} }
  }

  pub fn packet_end_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_packet_end_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn packet_end_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_packet_end_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_discarded_events_borrow_stream_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_beginning_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_events_borrow_beginning_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_end_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_events_borrow_end_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_discarded_events_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn discarded_events_get_count(&self, count: *mut u64) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_discarded_events_get_count(self.ptr, count)).unwrap() }
  }

  pub fn discarded_packets_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_discarded_packets_borrow_stream_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_beginning_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_packets_borrow_beginning_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_end_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_packets_borrow_end_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_discarded_packets_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn discarded_packets_get_count(&self, count: *mut u64) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_discarded_packets_get_count(self.ptr, count)).unwrap() }
  }

  pub fn message_iterator_inactivity_borrow_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_message_iterator_inactivity_borrow_clock_snapshot_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_put_ref(self.ptr) }
  }

}
pub struct BtMessage {
    ptr: *mut bt_message
}
impl BtMessage {
    pub fn empty() -> BtMessage {
        BtMessage { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_message) -> BtMessage {
        BtMessage { ptr }
    }
    pub fn as_const(&mut self) -> BtMessageConst {
      BtMessageConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtMessageType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_get_type(self.ptr)).unwrap() }
  }

  pub unsafe fn stream_beginning_create(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_stream_beginning_create(self_message_iterator.ptr, stream.ptr)} }
  }

  pub fn stream_beginning_borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_message_stream_beginning_borrow_stream(self.ptr)} }
  }

  pub fn stream_beginning_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_stream_beginning_borrow_stream_const(self.ptr)} }
  }

  pub fn stream_beginning_set_default_clock_snapshot(&mut self, value: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_stream_beginning_set_default_clock_snapshot(self.ptr, value) }
  }

  pub unsafe fn stream_beginning_borrow_default_clock_snapshot_const(&self, clock_snapshot: *mut *const bt_clock_snapshot) -> BtMessageStreamClockSnapshotState {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_stream_beginning_borrow_default_clock_snapshot_const(self.ptr, clock_snapshot)).unwrap() }
  }

  pub fn stream_beginning_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_stream_beginning_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn stream_end_create(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_stream_end_create(self_message_iterator.ptr, stream.ptr)} }
  }

  pub fn stream_end_borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_message_stream_end_borrow_stream(self.ptr)} }
  }

  pub fn stream_end_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_stream_end_borrow_stream_const(self.ptr)} }
  }

  pub fn stream_end_set_default_clock_snapshot(&mut self, value: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_stream_end_set_default_clock_snapshot(self.ptr, value) }
  }

  pub unsafe fn stream_end_borrow_default_clock_snapshot_const(&self, clock_snapshot: *mut *const bt_clock_snapshot) -> BtMessageStreamClockSnapshotState {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_stream_end_borrow_default_clock_snapshot_const(self.ptr, clock_snapshot)).unwrap() }
  }

  pub fn stream_end_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_stream_end_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn event_create(self_message_iterator: &BtSelfMessageIterator, event_class: &BtEventClassConst, stream: &BtStreamConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_event_create(self_message_iterator.ptr, event_class.ptr, stream.ptr)} }
  }

  pub unsafe fn event_create_with_default_clock_snapshot(self_message_iterator: &BtSelfMessageIterator, event_class: &BtEventClassConst, stream: &BtStreamConst, clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_event_create_with_default_clock_snapshot(self_message_iterator.ptr, event_class.ptr, stream.ptr, clock_snapshot_value)} }
  }

  pub unsafe fn event_create_with_packet(self_message_iterator: &BtSelfMessageIterator, event_class: &BtEventClassConst, packet: &BtPacketConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_event_create_with_packet(self_message_iterator.ptr, event_class.ptr, packet.ptr)} }
  }

  pub unsafe fn event_create_with_packet_and_default_clock_snapshot(self_message_iterator: &BtSelfMessageIterator, event_class: &BtEventClassConst, packet: &BtPacketConst, clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_event_create_with_packet_and_default_clock_snapshot(self_message_iterator.ptr, event_class.ptr, packet.ptr, clock_snapshot_value)} }
  }

  pub fn event_borrow_event(&mut self) -> BtEvent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEvent{ ptr:bt_message_event_borrow_event(self.ptr)} }
  }

  pub fn event_borrow_event_const(&self) -> BtEventConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventConst{ ptr:bt_message_event_borrow_event_const(self.ptr)} }
  }

  pub fn event_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_event_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn event_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_event_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn packet_beginning_create(self_message_iterator: &BtSelfMessageIterator, packet: &BtPacketConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_packet_beginning_create(self_message_iterator.ptr, packet.ptr)} }
  }

  pub unsafe fn packet_beginning_create_with_default_clock_snapshot(self_message_iterator: &BtSelfMessageIterator, packet: &BtPacketConst, clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_packet_beginning_create_with_default_clock_snapshot(self_message_iterator.ptr, packet.ptr, clock_snapshot_value)} }
  }

  pub fn packet_beginning_borrow_packet(&mut self) -> BtPacket {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacket{ ptr:bt_message_packet_beginning_borrow_packet(self.ptr)} }
  }

  pub fn packet_beginning_borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_message_packet_beginning_borrow_packet_const(self.ptr)} }
  }

  pub fn packet_beginning_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_packet_beginning_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn packet_beginning_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_packet_beginning_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn packet_end_create(self_message_iterator: &BtSelfMessageIterator, packet: &BtPacketConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_packet_end_create(self_message_iterator.ptr, packet.ptr)} }
  }

  pub unsafe fn packet_end_create_with_default_clock_snapshot(self_message_iterator: &BtSelfMessageIterator, packet: &BtPacketConst, clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_packet_end_create_with_default_clock_snapshot(self_message_iterator.ptr, packet.ptr, clock_snapshot_value)} }
  }

  pub fn packet_end_borrow_packet(&mut self) -> BtPacket {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacket{ ptr:bt_message_packet_end_borrow_packet(self.ptr)} }
  }

  pub fn packet_end_borrow_packet_const(&self) -> BtPacketConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPacketConst{ ptr:bt_message_packet_end_borrow_packet_const(self.ptr)} }
  }

  pub fn packet_end_borrow_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_packet_end_borrow_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn packet_end_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_packet_end_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn discarded_events_create(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_discarded_events_create(self_message_iterator.ptr, stream.ptr)} }
  }

  pub unsafe fn discarded_events_create_with_default_clock_snapshots(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst, beginning_clock_snapshot_value: u64, end_clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_discarded_events_create_with_default_clock_snapshots(self_message_iterator.ptr, stream.ptr, beginning_clock_snapshot_value, end_clock_snapshot_value)} }
  }

  pub fn discarded_events_borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_message_discarded_events_borrow_stream(self.ptr)} }
  }

  pub fn discarded_events_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_discarded_events_borrow_stream_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_beginning_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_events_borrow_beginning_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_end_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_events_borrow_end_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_events_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_discarded_events_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn discarded_events_set_count(&mut self, count: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_discarded_events_set_count(self.ptr, count) }
  }

  pub unsafe fn discarded_events_get_count(&self, count: *mut u64) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_discarded_events_get_count(self.ptr, count)).unwrap() }
  }

  pub unsafe fn discarded_packets_create(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_discarded_packets_create(self_message_iterator.ptr, stream.ptr)} }
  }

  pub unsafe fn discarded_packets_create_with_default_clock_snapshots(self_message_iterator: &BtSelfMessageIterator, stream: &BtStreamConst, beginning_clock_snapshot_value: u64, end_clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_discarded_packets_create_with_default_clock_snapshots(self_message_iterator.ptr, stream.ptr, beginning_clock_snapshot_value, end_clock_snapshot_value)} }
  }

  pub fn discarded_packets_borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_message_discarded_packets_borrow_stream(self.ptr)} }
  }

  pub fn discarded_packets_borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_message_discarded_packets_borrow_stream_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_beginning_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_packets_borrow_beginning_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_end_default_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_discarded_packets_borrow_end_default_clock_snapshot_const(self.ptr)} }
  }

  pub fn discarded_packets_borrow_stream_class_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_message_discarded_packets_borrow_stream_class_default_clock_class_const(self.ptr)} }
  }

  pub fn discarded_packets_set_count(&mut self, count: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_discarded_packets_set_count(self.ptr, count) }
  }

  pub unsafe fn discarded_packets_get_count(&self, count: *mut u64) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_discarded_packets_get_count(self.ptr, count)).unwrap() }
  }

  pub unsafe fn message_iterator_inactivity_create(self_message_iterator: &BtSelfMessageIterator, clock_class: &BtClockClassConst, clock_snapshot_value: u64) -> BtMessage {
    unsafe { BtMessage{ ptr:bt_message_message_iterator_inactivity_create(self_message_iterator.ptr, clock_class.ptr, clock_snapshot_value)} }
  }

  pub fn message_iterator_inactivity_borrow_clock_snapshot_const(&self) -> BtClockSnapshotConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockSnapshotConst{ ptr:bt_message_message_iterator_inactivity_borrow_clock_snapshot_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_put_ref(self.ptr) }
  }

}
pub struct BtMessageIteratorConst {
    ptr: *const bt_message_iterator
}
impl BtMessageIteratorConst {
    pub fn empty() -> BtMessageIteratorConst {
        BtMessageIteratorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_message_iterator) -> BtMessageIteratorConst {
        BtMessageIteratorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_put_ref(self.ptr) }
  }

}
pub struct BtMessageIterator {
    ptr: *mut bt_message_iterator
}
impl BtMessageIterator {
    pub fn empty() -> BtMessageIterator {
        BtMessageIterator { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_message_iterator) -> BtMessageIterator {
        BtMessageIterator { ptr }
    }
    pub fn as_const(&mut self) -> BtMessageIteratorConst {
      BtMessageIteratorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create_from_message_iterator(self_message_iterator: &BtSelfMessageIterator, port: &BtSelfComponentPortInput, message_iterator: *mut *mut bt_message_iterator) -> BtMessageIteratorCreateFromMessageIteratorStatus {
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_create_from_message_iterator(self_message_iterator.ptr, port.ptr, message_iterator)).unwrap() }
  }

  pub unsafe fn create_from_sink_component(self_component_sink: &BtSelfComponentSink, port: &BtSelfComponentPortInput, message_iterator: *mut *mut bt_message_iterator) -> BtMessageIteratorCreateFromSinkComponentStatus {
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_create_from_sink_component(self_component_sink.ptr, port.ptr, message_iterator)).unwrap() }
  }

  pub fn borrow_component(&mut self) -> BtComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponent{ ptr:bt_message_iterator_borrow_component(self.ptr)} }
  }

  pub unsafe fn next(&mut self, messages: *mut bt_message_array_const, count: *mut u64) -> BtMessageIteratorNextStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_next(self.ptr, messages, count)).unwrap() }
  }

  pub unsafe fn can_seek_beginning(&mut self, can_seek_beginning: *mut bt_bool) -> BtMessageIteratorCanSeekBeginningStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_can_seek_beginning(self.ptr, can_seek_beginning)).unwrap() }
  }

  pub fn seek_beginning(&mut self) -> BtMessageIteratorSeekBeginningStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_seek_beginning(self.ptr)).unwrap() }
  }

  pub unsafe fn can_seek_ns_from_origin(&mut self, ns_from_origin: i64, can_seek_ns_from_origin: *mut bt_bool) -> BtMessageIteratorCanSeekNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_can_seek_ns_from_origin(self.ptr, ns_from_origin, can_seek_ns_from_origin)).unwrap() }
  }

  pub fn seek_ns_from_origin(&mut self, ns_from_origin: i64) -> BtMessageIteratorSeekNsFromOriginStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_message_iterator_seek_ns_from_origin(self.ptr, ns_from_origin)).unwrap() }
  }

  pub fn can_seek_forward(&mut self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_message_iterator_can_seek_forward(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_put_ref(self.ptr) }
  }

}
pub struct BtMessageIteratorClassConst {
    ptr: *const bt_message_iterator_class
}
impl BtMessageIteratorClassConst {
    pub fn empty() -> BtMessageIteratorClassConst {
        BtMessageIteratorClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_message_iterator_class) -> BtMessageIteratorClassConst {
        BtMessageIteratorClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_class_put_ref(self.ptr) }
  }

}
pub struct BtMessageIteratorClass {
    ptr: *mut bt_message_iterator_class
}
impl BtMessageIteratorClass {
    pub fn empty() -> BtMessageIteratorClass {
        BtMessageIteratorClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_message_iterator_class) -> BtMessageIteratorClass {
        BtMessageIteratorClass { ptr }
    }
    pub fn as_const(&mut self) -> BtMessageIteratorClassConst {
      BtMessageIteratorClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn create(next_method: bt_message_iterator_class_next_method) -> BtMessageIteratorClass {
    unsafe { BtMessageIteratorClass{ ptr:bt_message_iterator_class_create(next_method)} }
  }

  pub fn set_finalize_method(&mut self, method: bt_message_iterator_class_finalize_method) -> BtMessageIteratorClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_iterator_class_set_finalize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_initialize_method(&mut self, method: bt_message_iterator_class_initialize_method) -> BtMessageIteratorClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_iterator_class_set_initialize_method(self.ptr, method)).unwrap() }
  }

  pub fn set_seek_beginning_methods(&mut self, seek_method: bt_message_iterator_class_seek_beginning_method, can_seek_method: bt_message_iterator_class_can_seek_beginning_method) -> BtMessageIteratorClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_iterator_class_set_seek_beginning_methods(self.ptr, seek_method, can_seek_method)).unwrap() }
  }

  pub fn set_seek_ns_from_origin_methods(&mut self, seek_method: bt_message_iterator_class_seek_ns_from_origin_method, can_seek_method: bt_message_iterator_class_can_seek_ns_from_origin_method) -> BtMessageIteratorClassSetMethodStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_message_iterator_class_set_seek_ns_from_origin_methods(self.ptr, seek_method, can_seek_method)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_message_iterator_class_put_ref(self.ptr) }
  }

}
pub struct BtObjectConst {
    ptr: *const bt_object
}
impl BtObjectConst {
    pub fn empty() -> BtObjectConst {
        BtObjectConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_object) -> BtObjectConst {
        BtObjectConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtObject {
    ptr: *mut bt_object
}
impl BtObject {
    pub fn empty() -> BtObject {
        BtObject { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_object) -> BtObject {
        BtObject { ptr }
    }
    pub fn as_const(&mut self) -> BtObjectConst {
      BtObjectConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPacketConst {
    ptr: *const bt_packet
}
impl BtPacketConst {
    pub fn empty() -> BtPacketConst {
        BtPacketConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_packet) -> BtPacketConst {
        BtPacketConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_packet_borrow_stream_const(self.ptr)} }
  }

  pub fn borrow_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_packet_borrow_context_field_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_packet_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_packet_put_ref(self.ptr) }
  }

}
pub struct BtPacket {
    ptr: *mut bt_packet
}
impl BtPacket {
    pub fn empty() -> BtPacket {
        BtPacket { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_packet) -> BtPacket {
        BtPacket { ptr }
    }
    pub fn as_const(&mut self) -> BtPacketConst {
      BtPacketConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(stream: &BtStreamConst) -> BtPacket {
    unsafe { BtPacket{ ptr:bt_packet_create(stream.ptr)} }
  }

  pub fn borrow_stream(&mut self) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_packet_borrow_stream(self.ptr)} }
  }

  pub fn borrow_stream_const(&self) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_packet_borrow_stream_const(self.ptr)} }
  }

  pub fn borrow_context_field(&mut self) -> BtField {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtField{ ptr:bt_packet_borrow_context_field(self.ptr)} }
  }

  pub fn borrow_context_field_const(&self) -> BtFieldConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldConst{ ptr:bt_packet_borrow_context_field_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_packet_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_packet_put_ref(self.ptr) }
  }

}
pub struct BtPluginConst {
    ptr: *const bt_plugin
}
impl BtPluginConst {
    pub fn empty() -> BtPluginConst {
        BtPluginConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_plugin) -> BtPluginConst {
        BtPluginConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_name(self.ptr)) }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_description(self.ptr)) }
  }

  pub fn get_author(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_author(self.ptr)) }
  }

  pub fn get_license(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_license(self.ptr)) }
  }

  pub fn get_path(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_path(self.ptr)) }
  }

  pub unsafe fn get_version(&self, major: *mut ::std::os::raw::c_uint, minor: *mut ::std::os::raw::c_uint, patch: *mut ::std::os::raw::c_uint, extra: *mut *const ::std::os::raw::c_char) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_plugin_get_version(self.ptr, major, minor, patch, extra)).unwrap() }
  }

  pub fn get_source_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_source_component_class_count(self.ptr) }
  }

  pub fn get_filter_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_filter_component_class_count(self.ptr) }
  }

  pub fn get_sink_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_sink_component_class_count(self.ptr) }
  }

  pub fn borrow_source_component_class_by_index_const(&self, index: u64) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_plugin_borrow_source_component_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_filter_component_class_by_index_const(&self, index: u64) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_plugin_borrow_filter_component_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_sink_component_class_by_index_const(&self, index: u64) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_plugin_borrow_sink_component_class_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_source_component_class_by_name_const(&self, name: &str) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_plugin_borrow_source_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn borrow_filter_component_class_by_name_const(&self, name: &str) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_plugin_borrow_filter_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn borrow_sink_component_class_by_name_const(&self, name: &str) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_plugin_borrow_sink_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_put_ref(self.ptr) }
  }

}
pub struct BtPlugin {
    ptr: *mut bt_plugin
}
impl BtPlugin {
    pub fn empty() -> BtPlugin {
        BtPlugin { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_plugin) -> BtPlugin {
        BtPlugin { ptr }
    }
    pub fn as_const(&mut self) -> BtPluginConst {
      BtPluginConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_name(self.ptr)) }
  }

  pub fn get_description(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_description(self.ptr)) }
  }

  pub fn get_author(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_author(self.ptr)) }
  }

  pub fn get_license(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_license(self.ptr)) }
  }

  pub fn get_path(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_plugin_get_path(self.ptr)) }
  }

  pub unsafe fn get_version(&self, major: *mut ::std::os::raw::c_uint, minor: *mut ::std::os::raw::c_uint, patch: *mut ::std::os::raw::c_uint, extra: *mut *const ::std::os::raw::c_char) -> BtPropertyAvailability {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_plugin_get_version(self.ptr, major, minor, patch, extra)).unwrap() }
  }

  pub fn get_source_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_source_component_class_count(self.ptr) }
  }

  pub fn get_filter_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_filter_component_class_count(self.ptr) }
  }

  pub fn get_sink_component_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_sink_component_class_count(self.ptr) }
  }

  pub fn borrow_source_component_class_by_index_const(&self, index: u64) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_plugin_borrow_source_component_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_filter_component_class_by_index_const(&self, index: u64) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_plugin_borrow_filter_component_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_sink_component_class_by_index_const(&self, index: u64) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_plugin_borrow_sink_component_class_by_index_const(self.ptr, index)} }
  }

  pub unsafe fn borrow_source_component_class_by_name_const(&self, name: &str) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_plugin_borrow_source_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn borrow_filter_component_class_by_name_const(&self, name: &str) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_plugin_borrow_filter_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn borrow_sink_component_class_by_name_const(&self, name: &str) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_plugin_borrow_sink_component_class_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_put_ref(self.ptr) }
  }

}
pub struct BtPluginSetConst {
    ptr: *const bt_plugin_set
}
impl BtPluginSetConst {
    pub fn empty() -> BtPluginSetConst {
        BtPluginSetConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_plugin_set) -> BtPluginSetConst {
        BtPluginSetConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_plugin_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_get_plugin_count(self.ptr) }
  }

  pub fn borrow_plugin_by_index_const(&self, index: u64) -> BtPluginConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPluginConst{ ptr:bt_plugin_set_borrow_plugin_by_index_const(self.ptr, index)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_put_ref(self.ptr) }
  }

}
pub struct BtPluginSet {
    ptr: *mut bt_plugin_set
}
impl BtPluginSet {
    pub fn empty() -> BtPluginSet {
        BtPluginSet { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_plugin_set) -> BtPluginSet {
        BtPluginSet { ptr }
    }
    pub fn as_const(&mut self) -> BtPluginSetConst {
      BtPluginSetConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_plugin_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_get_plugin_count(self.ptr) }
  }

  pub fn borrow_plugin_by_index_const(&self, index: u64) -> BtPluginConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPluginConst{ ptr:bt_plugin_set_borrow_plugin_by_index_const(self.ptr, index)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_plugin_set_put_ref(self.ptr) }
  }

}
pub struct BtPluginSoSharedLibHandleConst {
    ptr: *const bt_plugin_so_shared_lib_handle
}
impl BtPluginSoSharedLibHandleConst {
    pub fn empty() -> BtPluginSoSharedLibHandleConst {
        BtPluginSoSharedLibHandleConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_plugin_so_shared_lib_handle) -> BtPluginSoSharedLibHandleConst {
        BtPluginSoSharedLibHandleConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPluginSoSharedLibHandle {
    ptr: *mut bt_plugin_so_shared_lib_handle
}
impl BtPluginSoSharedLibHandle {
    pub fn empty() -> BtPluginSoSharedLibHandle {
        BtPluginSoSharedLibHandle { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_plugin_so_shared_lib_handle) -> BtPluginSoSharedLibHandle {
        BtPluginSoSharedLibHandle { ptr }
    }
    pub fn as_const(&mut self) -> BtPluginSoSharedLibHandleConst {
      BtPluginSoSharedLibHandleConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPortConst {
    ptr: *const bt_port
}
impl BtPortConst {
    pub fn empty() -> BtPortConst {
        BtPortConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_port) -> BtPortConst {
        BtPortConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtPortType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_port_get_type(self.ptr)).unwrap() }
  }

  pub fn borrow_connection_const(&self) -> BtConnectionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtConnectionConst{ ptr:bt_port_borrow_connection_const(self.ptr)} }
  }

  pub fn borrow_component_const(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_port_borrow_component_const(self.ptr)} }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_port_get_name(self.ptr)) }
  }

  pub fn is_connected(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_connected(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_put_ref(self.ptr) }
  }

  pub fn is_input_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_input_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_output_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_output_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtPort {
    ptr: *mut bt_port
}
impl BtPort {
    pub fn empty() -> BtPort {
        BtPort { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_port) -> BtPort {
        BtPort { ptr }
    }
    pub fn as_const(&mut self) -> BtPortConst {
      BtPortConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtPortType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_port_get_type(self.ptr)).unwrap() }
  }

  pub fn borrow_connection_const(&self) -> BtConnectionConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtConnectionConst{ ptr:bt_port_borrow_connection_const(self.ptr)} }
  }

  pub fn borrow_component_const(&self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_port_borrow_component_const(self.ptr)} }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_port_get_name(self.ptr)) }
  }

  pub fn is_connected(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_connected(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_put_ref(self.ptr) }
  }

  pub fn is_input_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_input_inline(self.ptr) as u32) != BT_FALSE }
  }

  pub fn is_output_inline(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_port_is_output_inline(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtPortInputConst {
    ptr: *const bt_port_input
}
impl BtPortInputConst {
    pub fn empty() -> BtPortInputConst {
        BtPortInputConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_port_input) -> BtPortInputConst {
        BtPortInputConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_input_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_input_put_ref(self.ptr) }
  }

  pub fn as_port_const_inline(&self) -> BtPortConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortConst{ ptr:bt_port_input_as_port_const_inline(self.ptr)} }
  }

}
pub struct BtPortInput {
    ptr: *mut bt_port_input
}
impl BtPortInput {
    pub fn empty() -> BtPortInput {
        BtPortInput { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_port_input) -> BtPortInput {
        BtPortInput { ptr }
    }
    pub fn as_const(&mut self) -> BtPortInputConst {
      BtPortInputConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_input_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_input_put_ref(self.ptr) }
  }

  pub fn as_port_const_inline(&self) -> BtPortConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortConst{ ptr:bt_port_input_as_port_const_inline(self.ptr)} }
  }

}
pub struct BtPortOutputConst {
    ptr: *const bt_port_output
}
impl BtPortOutputConst {
    pub fn empty() -> BtPortOutputConst {
        BtPortOutputConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_port_output) -> BtPortOutputConst {
        BtPortOutputConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_output_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_output_put_ref(self.ptr) }
  }

  pub fn as_port_const_inline(&self) -> BtPortConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortConst{ ptr:bt_port_output_as_port_const_inline(self.ptr)} }
  }

}
pub struct BtPortOutput {
    ptr: *mut bt_port_output
}
impl BtPortOutput {
    pub fn empty() -> BtPortOutput {
        BtPortOutput { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_port_output) -> BtPortOutput {
        BtPortOutput { ptr }
    }
    pub fn as_const(&mut self) -> BtPortOutputConst {
      BtPortOutputConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_output_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_port_output_put_ref(self.ptr) }
  }

  pub fn as_port_const_inline(&self) -> BtPortConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortConst{ ptr:bt_port_output_as_port_const_inline(self.ptr)} }
  }

}
pub struct BtPortOutputMessageIteratorConst {
    ptr: *const bt_port_output_message_iterator
}
impl BtPortOutputMessageIteratorConst {
    pub fn empty() -> BtPortOutputMessageIteratorConst {
        BtPortOutputMessageIteratorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_port_output_message_iterator) -> BtPortOutputMessageIteratorConst {
        BtPortOutputMessageIteratorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPortOutputMessageIterator {
    ptr: *mut bt_port_output_message_iterator
}
impl BtPortOutputMessageIterator {
    pub fn empty() -> BtPortOutputMessageIterator {
        BtPortOutputMessageIterator { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_port_output_message_iterator) -> BtPortOutputMessageIterator {
        BtPortOutputMessageIterator { ptr }
    }
    pub fn as_const(&mut self) -> BtPortOutputMessageIteratorConst {
      BtPortOutputMessageIteratorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPrivateQueryExecutorConst {
    ptr: *const bt_private_query_executor
}
impl BtPrivateQueryExecutorConst {
    pub fn empty() -> BtPrivateQueryExecutorConst {
        BtPrivateQueryExecutorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_private_query_executor) -> BtPrivateQueryExecutorConst {
        BtPrivateQueryExecutorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtPrivateQueryExecutor {
    ptr: *mut bt_private_query_executor
}
impl BtPrivateQueryExecutor {
    pub fn empty() -> BtPrivateQueryExecutor {
        BtPrivateQueryExecutor { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_private_query_executor) -> BtPrivateQueryExecutor {
        BtPrivateQueryExecutor { ptr }
    }
    pub fn as_const(&mut self) -> BtPrivateQueryExecutorConst {
      BtPrivateQueryExecutorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_query_executor_const_inline(&mut self) -> BtQueryExecutorConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtQueryExecutorConst{ ptr:bt_private_query_executor_as_query_executor_const_inline(self.ptr)} }
  }

}
pub struct BtQueryExecutorConst {
    ptr: *const bt_query_executor
}
impl BtQueryExecutorConst {
    pub fn empty() -> BtQueryExecutorConst {
        BtQueryExecutorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_query_executor) -> BtQueryExecutorConst {
        BtQueryExecutorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_logging_level(&self) -> BtLoggingLevel {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_query_executor_get_logging_level(self.ptr)).unwrap() }
  }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_query_executor_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_query_executor_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_query_executor_put_ref(self.ptr) }
  }

}
pub struct BtQueryExecutor {
    ptr: *mut bt_query_executor
}
impl BtQueryExecutor {
    pub fn empty() -> BtQueryExecutor {
        BtQueryExecutor { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_query_executor) -> BtQueryExecutor {
        BtQueryExecutor { ptr }
    }
    pub fn as_const(&mut self) -> BtQueryExecutorConst {
      BtQueryExecutorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(component_class: &BtComponentClassConst, object_name: &str, params: &BtValueConst) -> BtQueryExecutor {
    unsafe { BtQueryExecutor{ ptr:bt_query_executor_create(component_class.ptr, object_name.as_ptr(), params.ptr)} }
  }

  pub unsafe fn create_with_method_data(component_class: &BtComponentClassConst, object_name: &str, params: &BtValueConst, method_data: *mut ::std::os::raw::c_void) -> BtQueryExecutor {
    unsafe { BtQueryExecutor{ ptr:bt_query_executor_create_with_method_data(component_class.ptr, object_name.as_ptr(), params.ptr, method_data)} }
  }

  pub unsafe fn query(&mut self, result: *mut *const bt_value) -> BtQueryExecutorQueryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_query_executor_query(self.ptr, result)).unwrap() }
  }

  pub fn set_logging_level(&mut self, logging_level: BtLoggingLevel) -> BtQueryExecutorSetLoggingLevelStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_query_executor_set_logging_level(self.ptr, num::ToPrimitive::to_u32(&logging_level).unwrap())).unwrap() }
  }

  pub fn get_logging_level(&self) -> BtLoggingLevel {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_query_executor_get_logging_level(self.ptr)).unwrap() }
  }

  pub unsafe fn add_interrupter(&mut self, interrupter: &BtInterrupterConst) -> BtQueryExecutorAddInterrupterStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_query_executor_add_interrupter(self.ptr, interrupter.ptr)).unwrap() }
  }

  pub fn borrow_default_interrupter(&mut self) -> BtInterrupter {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtInterrupter{ ptr:bt_query_executor_borrow_default_interrupter(self.ptr)} }
  }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_query_executor_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_query_executor_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_query_executor_put_ref(self.ptr) }
  }

}
pub struct BtSelfComponentConst {
    ptr: *const bt_self_component
}
impl BtSelfComponentConst {
    pub fn empty() -> BtSelfComponentConst {
        BtSelfComponentConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component) -> BtSelfComponentConst {
        BtSelfComponentConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_get_data(self.ptr) }
  }

}
pub struct BtSelfComponent {
    ptr: *mut bt_self_component
}
impl BtSelfComponent {
    pub fn empty() -> BtSelfComponent {
        BtSelfComponent { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component) -> BtSelfComponent {
        BtSelfComponent { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentConst {
      BtSelfComponentConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn set_data(&mut self, user_data: *mut ::std::os::raw::c_void)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_set_data(self.ptr, user_data) }
  }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_get_data(self.ptr) }
  }

  pub fn get_graph_mip_version(&mut self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_get_graph_mip_version(self.ptr) }
  }

  pub fn as_component_inline(&mut self) -> BtComponentConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentConst{ ptr:bt_self_component_as_component_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentClassConst {
    ptr: *const bt_self_component_class
}
impl BtSelfComponentClassConst {
    pub fn empty() -> BtSelfComponentClassConst {
        BtSelfComponentClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_class) -> BtSelfComponentClassConst {
        BtSelfComponentClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentClass {
    ptr: *mut bt_self_component_class
}
impl BtSelfComponentClass {
    pub fn empty() -> BtSelfComponentClass {
        BtSelfComponentClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_class) -> BtSelfComponentClass {
        BtSelfComponentClass { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentClassConst {
      BtSelfComponentClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_component_class_inline(&mut self) -> BtComponentClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassConst{ ptr:bt_self_component_class_as_component_class_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentClassFilterConst {
    ptr: *const bt_self_component_class_filter
}
impl BtSelfComponentClassFilterConst {
    pub fn empty() -> BtSelfComponentClassFilterConst {
        BtSelfComponentClassFilterConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_class_filter) -> BtSelfComponentClassFilterConst {
        BtSelfComponentClassFilterConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentClassFilter {
    ptr: *mut bt_self_component_class_filter
}
impl BtSelfComponentClassFilter {
    pub fn empty() -> BtSelfComponentClassFilter {
        BtSelfComponentClassFilter { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_class_filter) -> BtSelfComponentClassFilter {
        BtSelfComponentClassFilter { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentClassFilterConst {
      BtSelfComponentClassFilterConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_component_class_filter_inline(&mut self) -> BtComponentClassFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassFilterConst{ ptr:bt_self_component_class_filter_as_component_class_filter_inline(self.ptr)} }
  }

  pub fn as_self_component_class_inline(&mut self) -> BtSelfComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentClass{ ptr:bt_self_component_class_filter_as_self_component_class_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentClassSinkConst {
    ptr: *const bt_self_component_class_sink
}
impl BtSelfComponentClassSinkConst {
    pub fn empty() -> BtSelfComponentClassSinkConst {
        BtSelfComponentClassSinkConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_class_sink) -> BtSelfComponentClassSinkConst {
        BtSelfComponentClassSinkConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentClassSink {
    ptr: *mut bt_self_component_class_sink
}
impl BtSelfComponentClassSink {
    pub fn empty() -> BtSelfComponentClassSink {
        BtSelfComponentClassSink { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_class_sink) -> BtSelfComponentClassSink {
        BtSelfComponentClassSink { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentClassSinkConst {
      BtSelfComponentClassSinkConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_component_class_sink_inline(&mut self) -> BtComponentClassSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSinkConst{ ptr:bt_self_component_class_sink_as_component_class_sink_inline(self.ptr)} }
  }

  pub fn as_self_component_class_inline(&mut self) -> BtSelfComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentClass{ ptr:bt_self_component_class_sink_as_self_component_class_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentClassSourceConst {
    ptr: *const bt_self_component_class_source
}
impl BtSelfComponentClassSourceConst {
    pub fn empty() -> BtSelfComponentClassSourceConst {
        BtSelfComponentClassSourceConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_class_source) -> BtSelfComponentClassSourceConst {
        BtSelfComponentClassSourceConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentClassSource {
    ptr: *mut bt_self_component_class_source
}
impl BtSelfComponentClassSource {
    pub fn empty() -> BtSelfComponentClassSource {
        BtSelfComponentClassSource { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_class_source) -> BtSelfComponentClassSource {
        BtSelfComponentClassSource { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentClassSourceConst {
      BtSelfComponentClassSourceConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_component_class_source_inline(&mut self) -> BtComponentClassSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentClassSourceConst{ ptr:bt_self_component_class_source_as_component_class_source_inline(self.ptr)} }
  }

  pub fn as_self_component_class_inline(&mut self) -> BtSelfComponentClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentClass{ ptr:bt_self_component_class_source_as_self_component_class_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentFilterConst {
    ptr: *const bt_self_component_filter
}
impl BtSelfComponentFilterConst {
    pub fn empty() -> BtSelfComponentFilterConst {
        BtSelfComponentFilterConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_filter) -> BtSelfComponentFilterConst {
        BtSelfComponentFilterConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentFilter {
    ptr: *mut bt_self_component_filter
}
impl BtSelfComponentFilter {
    pub fn empty() -> BtSelfComponentFilter {
        BtSelfComponentFilter { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_filter) -> BtSelfComponentFilter {
        BtSelfComponentFilter { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentFilterConst {
      BtSelfComponentFilterConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn add_input_port(&mut self, name: &str, user_data: *mut ::std::os::raw::c_void, self_component_port: *mut *mut bt_self_component_port_input) -> BtSelfComponentAddPortStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_self_component_filter_add_input_port(self.ptr, name.as_ptr(), user_data, self_component_port)).unwrap() }
  }

  pub unsafe fn add_output_port(&mut self, name: &str, user_data: *mut ::std::os::raw::c_void, self_component_port: *mut *mut bt_self_component_port_output) -> BtSelfComponentAddPortStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_self_component_filter_add_output_port(self.ptr, name.as_ptr(), user_data, self_component_port)).unwrap() }
  }

  pub fn borrow_input_port_by_index(&mut self, index: u64) -> BtSelfComponentPortInput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortInput{ ptr:bt_self_component_filter_borrow_input_port_by_index(self.ptr, index)} }
  }

  pub fn borrow_output_port_by_index(&mut self, index: u64) -> BtSelfComponentPortOutput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortOutput{ ptr:bt_self_component_filter_borrow_output_port_by_index(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name(&mut self, name: &str) -> BtSelfComponentPortInput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortInput{ ptr:bt_self_component_filter_borrow_input_port_by_name(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn borrow_output_port_by_name(&mut self, name: &str) -> BtSelfComponentPortOutput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortOutput{ ptr:bt_self_component_filter_borrow_output_port_by_name(self.ptr, name.as_ptr())} }
  }

  pub fn as_component_filter_inline(&mut self) -> BtComponentFilterConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentFilterConst{ ptr:bt_self_component_filter_as_component_filter_inline(self.ptr)} }
  }

  pub fn as_self_component_inline(&mut self) -> BtSelfComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponent{ ptr:bt_self_component_filter_as_self_component_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentFilterConfigurationConst {
    ptr: *const bt_self_component_filter_configuration
}
impl BtSelfComponentFilterConfigurationConst {
    pub fn empty() -> BtSelfComponentFilterConfigurationConst {
        BtSelfComponentFilterConfigurationConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_filter_configuration) -> BtSelfComponentFilterConfigurationConst {
        BtSelfComponentFilterConfigurationConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentFilterConfiguration {
    ptr: *mut bt_self_component_filter_configuration
}
impl BtSelfComponentFilterConfiguration {
    pub fn empty() -> BtSelfComponentFilterConfiguration {
        BtSelfComponentFilterConfiguration { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_filter_configuration) -> BtSelfComponentFilterConfiguration {
        BtSelfComponentFilterConfiguration { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentFilterConfigurationConst {
      BtSelfComponentFilterConfigurationConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentPortConst {
    ptr: *const bt_self_component_port
}
impl BtSelfComponentPortConst {
    pub fn empty() -> BtSelfComponentPortConst {
        BtSelfComponentPortConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_port) -> BtSelfComponentPortConst {
        BtSelfComponentPortConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_port_get_data(self.ptr) }
  }

}
pub struct BtSelfComponentPort {
    ptr: *mut bt_self_component_port
}
impl BtSelfComponentPort {
    pub fn empty() -> BtSelfComponentPort {
        BtSelfComponentPort { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_port) -> BtSelfComponentPort {
        BtSelfComponentPort { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentPortConst {
      BtSelfComponentPortConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_component(&mut self) -> BtSelfComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponent{ ptr:bt_self_component_port_borrow_component(self.ptr)} }
  }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_component_port_get_data(self.ptr) }
  }

  pub fn as_port_inline(&mut self) -> BtPortConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortConst{ ptr:bt_self_component_port_as_port_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentPortInputConst {
    ptr: *const bt_self_component_port_input
}
impl BtSelfComponentPortInputConst {
    pub fn empty() -> BtSelfComponentPortInputConst {
        BtSelfComponentPortInputConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_port_input) -> BtSelfComponentPortInputConst {
        BtSelfComponentPortInputConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_port_input_inline(&self) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_self_component_port_input_as_port_input_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentPortInput {
    ptr: *mut bt_self_component_port_input
}
impl BtSelfComponentPortInput {
    pub fn empty() -> BtSelfComponentPortInput {
        BtSelfComponentPortInput { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_port_input) -> BtSelfComponentPortInput {
        BtSelfComponentPortInput { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentPortInputConst {
      BtSelfComponentPortInputConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_port_input_inline(&self) -> BtPortInputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortInputConst{ ptr:bt_self_component_port_input_as_port_input_inline(self.ptr)} }
  }

  pub fn as_self_component_port_inline(&mut self) -> BtSelfComponentPort {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPort{ ptr:bt_self_component_port_input_as_self_component_port_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentPortOutputConst {
    ptr: *const bt_self_component_port_output
}
impl BtSelfComponentPortOutputConst {
    pub fn empty() -> BtSelfComponentPortOutputConst {
        BtSelfComponentPortOutputConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_port_output) -> BtSelfComponentPortOutputConst {
        BtSelfComponentPortOutputConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentPortOutput {
    ptr: *mut bt_self_component_port_output
}
impl BtSelfComponentPortOutput {
    pub fn empty() -> BtSelfComponentPortOutput {
        BtSelfComponentPortOutput { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_port_output) -> BtSelfComponentPortOutput {
        BtSelfComponentPortOutput { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentPortOutputConst {
      BtSelfComponentPortOutputConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn as_port_output_inline(&mut self) -> BtPortOutputConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtPortOutputConst{ ptr:bt_self_component_port_output_as_port_output_inline(self.ptr)} }
  }

  pub fn as_self_component_port_inline(&mut self) -> BtSelfComponentPort {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPort{ ptr:bt_self_component_port_output_as_self_component_port_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentSinkConst {
    ptr: *const bt_self_component_sink
}
impl BtSelfComponentSinkConst {
    pub fn empty() -> BtSelfComponentSinkConst {
        BtSelfComponentSinkConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_sink) -> BtSelfComponentSinkConst {
        BtSelfComponentSinkConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_self_component_sink_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtSelfComponentSink {
    ptr: *mut bt_self_component_sink
}
impl BtSelfComponentSink {
    pub fn empty() -> BtSelfComponentSink {
        BtSelfComponentSink { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_sink) -> BtSelfComponentSink {
        BtSelfComponentSink { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentSinkConst {
      BtSelfComponentSinkConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn add_input_port(&mut self, name: &str, user_data: *mut ::std::os::raw::c_void, self_component_port: *mut *mut bt_self_component_port_input) -> BtSelfComponentAddPortStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_self_component_sink_add_input_port(self.ptr, name.as_ptr(), user_data, self_component_port)).unwrap() }
  }

  pub fn borrow_input_port_by_index(&mut self, index: u64) -> BtSelfComponentPortInput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortInput{ ptr:bt_self_component_sink_borrow_input_port_by_index(self.ptr, index)} }
  }

  pub unsafe fn borrow_input_port_by_name(&mut self, name: &str) -> BtSelfComponentPortInput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortInput{ ptr:bt_self_component_sink_borrow_input_port_by_name(self.ptr, name.as_ptr())} }
  }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_self_component_sink_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

  pub fn as_component_sink_inline(&mut self) -> BtComponentSinkConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentSinkConst{ ptr:bt_self_component_sink_as_component_sink_inline(self.ptr)} }
  }

  pub fn as_self_component_inline(&mut self) -> BtSelfComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponent{ ptr:bt_self_component_sink_as_self_component_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentSinkConfigurationConst {
    ptr: *const bt_self_component_sink_configuration
}
impl BtSelfComponentSinkConfigurationConst {
    pub fn empty() -> BtSelfComponentSinkConfigurationConst {
        BtSelfComponentSinkConfigurationConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_sink_configuration) -> BtSelfComponentSinkConfigurationConst {
        BtSelfComponentSinkConfigurationConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentSinkConfiguration {
    ptr: *mut bt_self_component_sink_configuration
}
impl BtSelfComponentSinkConfiguration {
    pub fn empty() -> BtSelfComponentSinkConfiguration {
        BtSelfComponentSinkConfiguration { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_sink_configuration) -> BtSelfComponentSinkConfiguration {
        BtSelfComponentSinkConfiguration { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentSinkConfigurationConst {
      BtSelfComponentSinkConfigurationConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentSourceConst {
    ptr: *const bt_self_component_source
}
impl BtSelfComponentSourceConst {
    pub fn empty() -> BtSelfComponentSourceConst {
        BtSelfComponentSourceConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_source) -> BtSelfComponentSourceConst {
        BtSelfComponentSourceConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentSource {
    ptr: *mut bt_self_component_source
}
impl BtSelfComponentSource {
    pub fn empty() -> BtSelfComponentSource {
        BtSelfComponentSource { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_source) -> BtSelfComponentSource {
        BtSelfComponentSource { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentSourceConst {
      BtSelfComponentSourceConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn add_output_port(&mut self, name: &str, user_data: *mut ::std::os::raw::c_void, self_component_port: *mut *mut bt_self_component_port_output) -> BtSelfComponentAddPortStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_self_component_source_add_output_port(self.ptr, name.as_ptr(), user_data, self_component_port)).unwrap() }
  }

  pub fn borrow_output_port_by_index(&mut self, index: u64) -> BtSelfComponentPortOutput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortOutput{ ptr:bt_self_component_source_borrow_output_port_by_index(self.ptr, index)} }
  }

  pub unsafe fn borrow_output_port_by_name(&mut self, name: &str) -> BtSelfComponentPortOutput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortOutput{ ptr:bt_self_component_source_borrow_output_port_by_name(self.ptr, name.as_ptr())} }
  }

  pub fn as_component_source_inline(&mut self) -> BtComponentSourceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtComponentSourceConst{ ptr:bt_self_component_source_as_component_source_inline(self.ptr)} }
  }

  pub fn as_self_component_inline(&mut self) -> BtSelfComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponent{ ptr:bt_self_component_source_as_self_component_inline(self.ptr)} }
  }

}
pub struct BtSelfComponentSourceConfigurationConst {
    ptr: *const bt_self_component_source_configuration
}
impl BtSelfComponentSourceConfigurationConst {
    pub fn empty() -> BtSelfComponentSourceConfigurationConst {
        BtSelfComponentSourceConfigurationConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_component_source_configuration) -> BtSelfComponentSourceConfigurationConst {
        BtSelfComponentSourceConfigurationConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfComponentSourceConfiguration {
    ptr: *mut bt_self_component_source_configuration
}
impl BtSelfComponentSourceConfiguration {
    pub fn empty() -> BtSelfComponentSourceConfiguration {
        BtSelfComponentSourceConfiguration { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_component_source_configuration) -> BtSelfComponentSourceConfiguration {
        BtSelfComponentSourceConfiguration { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfComponentSourceConfigurationConst {
      BtSelfComponentSourceConfigurationConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfMessageIteratorConst {
    ptr: *const bt_self_message_iterator
}
impl BtSelfMessageIteratorConst {
    pub fn empty() -> BtSelfMessageIteratorConst {
        BtSelfMessageIteratorConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_message_iterator) -> BtSelfMessageIteratorConst {
        BtSelfMessageIteratorConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_message_iterator_get_data(self.ptr) }
  }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_self_message_iterator_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtSelfMessageIterator {
    ptr: *mut bt_self_message_iterator
}
impl BtSelfMessageIterator {
    pub fn empty() -> BtSelfMessageIterator {
        BtSelfMessageIterator { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_message_iterator) -> BtSelfMessageIterator {
        BtSelfMessageIterator { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfMessageIteratorConst {
      BtSelfMessageIteratorConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_component(&mut self) -> BtSelfComponent {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponent{ ptr:bt_self_message_iterator_borrow_component(self.ptr)} }
  }

  pub fn borrow_port(&mut self) -> BtSelfComponentPortOutput {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtSelfComponentPortOutput{ ptr:bt_self_message_iterator_borrow_port(self.ptr)} }
  }

  pub unsafe fn set_data(&mut self, user_data: *mut ::std::os::raw::c_void)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_message_iterator_set_data(self.ptr, user_data) }
  }

  pub fn get_data(&self) -> *mut ::std::os::raw::c_void {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_message_iterator_get_data(self.ptr) }
  }

  pub fn is_interrupted(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_self_message_iterator_is_interrupted(self.ptr) as u32) != BT_FALSE }
  }

}
pub struct BtSelfMessageIteratorConfigurationConst {
    ptr: *const bt_self_message_iterator_configuration
}
impl BtSelfMessageIteratorConfigurationConst {
    pub fn empty() -> BtSelfMessageIteratorConfigurationConst {
        BtSelfMessageIteratorConfigurationConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_message_iterator_configuration) -> BtSelfMessageIteratorConfigurationConst {
        BtSelfMessageIteratorConfigurationConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfMessageIteratorConfiguration {
    ptr: *mut bt_self_message_iterator_configuration
}
impl BtSelfMessageIteratorConfiguration {
    pub fn empty() -> BtSelfMessageIteratorConfiguration {
        BtSelfMessageIteratorConfiguration { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_message_iterator_configuration) -> BtSelfMessageIteratorConfiguration {
        BtSelfMessageIteratorConfiguration { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfMessageIteratorConfigurationConst {
      BtSelfMessageIteratorConfigurationConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn set_can_seek_forward(&mut self, can_seek_forward: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_self_message_iterator_configuration_set_can_seek_forward(self.ptr, if can_seek_forward { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

}
pub struct BtSelfPluginConst {
    ptr: *const bt_self_plugin
}
impl BtSelfPluginConst {
    pub fn empty() -> BtSelfPluginConst {
        BtSelfPluginConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_self_plugin) -> BtSelfPluginConst {
        BtSelfPluginConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtSelfPlugin {
    ptr: *mut bt_self_plugin
}
impl BtSelfPlugin {
    pub fn empty() -> BtSelfPlugin {
        BtSelfPlugin { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_self_plugin) -> BtSelfPlugin {
        BtSelfPlugin { ptr }
    }
    pub fn as_const(&mut self) -> BtSelfPluginConst {
      BtSelfPluginConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

}
pub struct BtStreamConst {
    ptr: *const bt_stream
}
impl BtStreamConst {
    pub fn empty() -> BtStreamConst {
        BtStreamConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_stream) -> BtStreamConst {
        BtStreamConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_stream_borrow_class_const(self.ptr)} }
  }

  pub fn borrow_trace_const(&self) -> BtTraceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceConst{ ptr:bt_stream_borrow_trace_const(self.ptr)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_get_id(self.ptr) }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_stream_get_name(self.ptr)) }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_stream_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_put_ref(self.ptr) }
  }

}
pub struct BtStream {
    ptr: *mut bt_stream
}
impl BtStream {
    pub fn empty() -> BtStream {
        BtStream { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_stream) -> BtStream {
        BtStream { ptr }
    }
    pub fn as_const(&mut self) -> BtStreamConst {
      BtStreamConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(stream_class: &BtStreamClass, trace: &BtTrace) -> BtStream {
    unsafe { BtStream{ ptr:bt_stream_create(stream_class.ptr, trace.ptr)} }
  }

  pub unsafe fn create_with_id(stream_class: &BtStreamClass, trace: &BtTrace, id: u64) -> BtStream {
    unsafe { BtStream{ ptr:bt_stream_create_with_id(stream_class.ptr, trace.ptr, id)} }
  }

  pub fn borrow_class(&mut self) -> BtStreamClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClass{ ptr:bt_stream_borrow_class(self.ptr)} }
  }

  pub fn borrow_class_const(&self) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_stream_borrow_class_const(self.ptr)} }
  }

  pub fn borrow_trace(&mut self) -> BtTrace {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTrace{ ptr:bt_stream_borrow_trace(self.ptr)} }
  }

  pub fn borrow_trace_const(&self) -> BtTraceConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceConst{ ptr:bt_stream_borrow_trace_const(self.ptr)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_get_id(self.ptr) }
  }

  pub unsafe fn set_name(&mut self, name: &str) -> BtStreamSetNameStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_stream_set_name(self.ptr, name.as_ptr())).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_stream_get_name(self.ptr)) }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_stream_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_stream_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_put_ref(self.ptr) }
  }

}
pub struct BtStreamClassConst {
    ptr: *const bt_stream_class
}
impl BtStreamClassConst {
    pub fn empty() -> BtStreamClassConst {
        BtStreamClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_stream_class) -> BtStreamClassConst {
        BtStreamClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_trace_class_const(&self) -> BtTraceClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClassConst{ ptr:bt_stream_class_borrow_trace_class_const(self.ptr)} }
  }

  pub fn get_event_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_event_class_count(self.ptr) }
  }

  pub fn borrow_event_class_by_index_const(&self, index: u64) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_stream_class_borrow_event_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_event_class_by_id_const(&self, id: u64) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_stream_class_borrow_event_class_by_id_const(self.ptr, id)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_id(self.ptr) }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_stream_class_get_name(self.ptr)) }
  }

  pub fn borrow_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_stream_class_borrow_default_clock_class_const(self.ptr)} }
  }

  pub fn borrow_packet_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_stream_class_borrow_packet_context_field_class_const(self.ptr)} }
  }

  pub fn borrow_event_common_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_stream_class_borrow_event_common_context_field_class_const(self.ptr)} }
  }

  pub fn assigns_automatic_event_class_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_assigns_automatic_event_class_id(self.ptr) as u32) != BT_FALSE }
  }

  pub fn assigns_automatic_stream_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_assigns_automatic_stream_id(self.ptr) as u32) != BT_FALSE }
  }

  pub fn supports_packets(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_packets(self.ptr) as u32) != BT_FALSE }
  }

  pub fn packets_have_beginning_default_clock_snapshot(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_packets_have_beginning_default_clock_snapshot(self.ptr) as u32) != BT_FALSE }
  }

  pub fn packets_have_end_default_clock_snapshot(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_packets_have_end_default_clock_snapshot(self.ptr) as u32) != BT_FALSE }
  }

  pub fn supports_discarded_events(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_discarded_events(self.ptr) as u32) != BT_FALSE }
  }

  pub fn discarded_events_have_default_clock_snapshots(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_discarded_events_have_default_clock_snapshots(self.ptr) as u32) != BT_FALSE }
  }

  pub fn supports_discarded_packets(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_discarded_packets(self.ptr) as u32) != BT_FALSE }
  }

  pub fn discarded_packets_have_default_clock_snapshots(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_discarded_packets_have_default_clock_snapshots(self.ptr) as u32) != BT_FALSE }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_stream_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_put_ref(self.ptr) }
  }

}
pub struct BtStreamClass {
    ptr: *mut bt_stream_class
}
impl BtStreamClass {
    pub fn empty() -> BtStreamClass {
        BtStreamClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_stream_class) -> BtStreamClass {
        BtStreamClass { ptr }
    }
    pub fn as_const(&mut self) -> BtStreamClassConst {
      BtStreamClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(trace_class: &BtTraceClass) -> BtStreamClass {
    unsafe { BtStreamClass{ ptr:bt_stream_class_create(trace_class.ptr)} }
  }

  pub unsafe fn create_with_id(trace_class: &BtTraceClass, id: u64) -> BtStreamClass {
    unsafe { BtStreamClass{ ptr:bt_stream_class_create_with_id(trace_class.ptr, id)} }
  }

  pub fn borrow_trace_class(&mut self) -> BtTraceClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClass{ ptr:bt_stream_class_borrow_trace_class(self.ptr)} }
  }

  pub fn borrow_trace_class_const(&self) -> BtTraceClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClassConst{ ptr:bt_stream_class_borrow_trace_class_const(self.ptr)} }
  }

  pub fn get_event_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_event_class_count(self.ptr) }
  }

  pub fn borrow_event_class_by_index(&mut self, index: u64) -> BtEventClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClass{ ptr:bt_stream_class_borrow_event_class_by_index(self.ptr, index)} }
  }

  pub fn borrow_event_class_by_index_const(&self, index: u64) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_stream_class_borrow_event_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_event_class_by_id(&mut self, id: u64) -> BtEventClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClass{ ptr:bt_stream_class_borrow_event_class_by_id(self.ptr, id)} }
  }

  pub fn borrow_event_class_by_id_const(&self, id: u64) -> BtEventClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtEventClassConst{ ptr:bt_stream_class_borrow_event_class_by_id_const(self.ptr, id)} }
  }

  pub fn get_id(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_id(self.ptr) }
  }

  pub unsafe fn set_name(&mut self, name: &str) -> BtStreamClassSetNameStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_stream_class_set_name(self.ptr, name.as_ptr())).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_stream_class_get_name(self.ptr)) }
  }

  pub unsafe fn set_default_clock_class(&mut self, clock_class: &BtClockClass) -> BtStreamClassSetDefaultClockClassStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_stream_class_set_default_clock_class(self.ptr, clock_class.ptr)).unwrap() }
  }

  pub fn borrow_default_clock_class(&mut self) -> BtClockClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClass{ ptr:bt_stream_class_borrow_default_clock_class(self.ptr)} }
  }

  pub fn borrow_default_clock_class_const(&self) -> BtClockClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtClockClassConst{ ptr:bt_stream_class_borrow_default_clock_class_const(self.ptr)} }
  }

  pub unsafe fn set_packet_context_field_class(&mut self, field_class: &BtFieldClass) -> BtStreamClassSetFieldClassStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_stream_class_set_packet_context_field_class(self.ptr, field_class.ptr)).unwrap() }
  }

  pub fn borrow_packet_context_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_stream_class_borrow_packet_context_field_class(self.ptr)} }
  }

  pub fn borrow_packet_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_stream_class_borrow_packet_context_field_class_const(self.ptr)} }
  }

  pub unsafe fn set_event_common_context_field_class(&mut self, field_class: &BtFieldClass) -> BtStreamClassSetFieldClassStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_stream_class_set_event_common_context_field_class(self.ptr, field_class.ptr)).unwrap() }
  }

  pub fn borrow_event_common_context_field_class(&mut self) -> BtFieldClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClass{ ptr:bt_stream_class_borrow_event_common_context_field_class(self.ptr)} }
  }

  pub fn borrow_event_common_context_field_class_const(&self) -> BtFieldClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtFieldClassConst{ ptr:bt_stream_class_borrow_event_common_context_field_class_const(self.ptr)} }
  }

  pub fn set_assigns_automatic_event_class_id(&mut self, assigns_automatic_event_class_id: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_assigns_automatic_event_class_id(self.ptr, if assigns_automatic_event_class_id { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn assigns_automatic_event_class_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_assigns_automatic_event_class_id(self.ptr) as u32) != BT_FALSE }
  }

  pub fn set_assigns_automatic_stream_id(&mut self, assigns_automatic_stream_id: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_assigns_automatic_stream_id(self.ptr, if assigns_automatic_stream_id { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn assigns_automatic_stream_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_assigns_automatic_stream_id(self.ptr) as u32) != BT_FALSE }
  }

  pub fn set_supports_packets(&mut self, supports_packets: bool, with_beginning_default_clock_snapshot: bool, with_end_default_clock_snapshot: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_supports_packets(self.ptr, if supports_packets { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }, if with_beginning_default_clock_snapshot { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }, if with_end_default_clock_snapshot { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn supports_packets(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_packets(self.ptr) as u32) != BT_FALSE }
  }

  pub fn packets_have_beginning_default_clock_snapshot(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_packets_have_beginning_default_clock_snapshot(self.ptr) as u32) != BT_FALSE }
  }

  pub fn packets_have_end_default_clock_snapshot(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_packets_have_end_default_clock_snapshot(self.ptr) as u32) != BT_FALSE }
  }

  pub fn set_supports_discarded_events(&mut self, supports_discarded_events: bool, with_default_clock_snapshots: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_supports_discarded_events(self.ptr, if supports_discarded_events { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }, if with_default_clock_snapshots { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn supports_discarded_events(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_discarded_events(self.ptr) as u32) != BT_FALSE }
  }

  pub fn discarded_events_have_default_clock_snapshots(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_discarded_events_have_default_clock_snapshots(self.ptr) as u32) != BT_FALSE }
  }

  pub fn set_supports_discarded_packets(&mut self, supports_discarded_packets: bool, with_default_clock_snapshots: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_supports_discarded_packets(self.ptr, if supports_discarded_packets { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }, if with_default_clock_snapshots { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn supports_discarded_packets(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_supports_discarded_packets(self.ptr) as u32) != BT_FALSE }
  }

  pub fn discarded_packets_have_default_clock_snapshots(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_stream_class_discarded_packets_have_default_clock_snapshots(self.ptr) as u32) != BT_FALSE }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_stream_class_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_stream_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_stream_class_put_ref(self.ptr) }
  }

}
pub struct BtTraceConst {
    ptr: *const bt_trace
}
impl BtTraceConst {
    pub fn empty() -> BtTraceConst {
        BtTraceConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_trace) -> BtTraceConst {
        BtTraceConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn borrow_class_const(&self) -> BtTraceClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClassConst{ ptr:bt_trace_borrow_class_const(self.ptr)} }
  }

  pub fn get_stream_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_stream_count(self.ptr) }
  }

  pub fn borrow_stream_by_index_const(&self, index: u64) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_trace_borrow_stream_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_stream_by_id_const(&self, id: u64) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_trace_borrow_stream_by_id_const(self.ptr, id)} }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_trace_get_name(self.ptr)) }
  }

  pub fn get_uuid(&self) -> bt_uuid {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_uuid(self.ptr) }
  }

  pub fn get_environment_entry_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_environment_entry_count(self.ptr) }
  }

  pub unsafe fn borrow_environment_entry_by_index_const(&self, index: u64, name: *mut *const ::std::os::raw::c_char, value: *mut *const bt_value)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_borrow_environment_entry_by_index_const(self.ptr, index, name, value) }
  }

  pub unsafe fn borrow_environment_entry_value_by_name_const(&self, name: &str) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_borrow_environment_entry_value_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn add_destruction_listener(&self, user_func: bt_trace_destruction_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtTraceAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_add_destruction_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub fn remove_destruction_listener(&self, listener_id: bt_listener_id) -> BtTraceRemoveListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_remove_destruction_listener(self.ptr, listener_id)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_put_ref(self.ptr) }
  }

}
pub struct BtTrace {
    ptr: *mut bt_trace
}
impl BtTrace {
    pub fn empty() -> BtTrace {
        BtTrace { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_trace) -> BtTrace {
        BtTrace { ptr }
    }
    pub fn as_const(&mut self) -> BtTraceConst {
      BtTraceConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(trace_class: &BtTraceClass) -> BtTrace {
    unsafe { BtTrace{ ptr:bt_trace_create(trace_class.ptr)} }
  }

  pub fn borrow_class(&mut self) -> BtTraceClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClass{ ptr:bt_trace_borrow_class(self.ptr)} }
  }

  pub fn borrow_class_const(&self) -> BtTraceClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtTraceClassConst{ ptr:bt_trace_borrow_class_const(self.ptr)} }
  }

  pub fn get_stream_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_stream_count(self.ptr) }
  }

  pub fn borrow_stream_by_index(&mut self, index: u64) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_trace_borrow_stream_by_index(self.ptr, index)} }
  }

  pub fn borrow_stream_by_index_const(&self, index: u64) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_trace_borrow_stream_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_stream_by_id(&mut self, id: u64) -> BtStream {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStream{ ptr:bt_trace_borrow_stream_by_id(self.ptr, id)} }
  }

  pub fn borrow_stream_by_id_const(&self, id: u64) -> BtStreamConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamConst{ ptr:bt_trace_borrow_stream_by_id_const(self.ptr, id)} }
  }

  pub unsafe fn set_name(&mut self, name: &str) -> BtTraceSetNameStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_set_name(self.ptr, name.as_ptr())).unwrap() }
  }

  pub fn get_name(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_trace_get_name(self.ptr)) }
  }

  pub unsafe fn set_uuid(&mut self, uuid: bt_uuid)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_set_uuid(self.ptr, uuid) }
  }

  pub fn get_uuid(&self) -> bt_uuid {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_uuid(self.ptr) }
  }

  pub unsafe fn set_environment_entry_integer(&mut self, name: &str, value: i64) -> BtTraceSetEnvironmentEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_set_environment_entry_integer(self.ptr, name.as_ptr(), value)).unwrap() }
  }

  pub unsafe fn set_environment_entry_string(&mut self, name: &str, value: &str) -> BtTraceSetEnvironmentEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_set_environment_entry_string(self.ptr, name.as_ptr(), value.as_ptr())).unwrap() }
  }

  pub fn get_environment_entry_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_environment_entry_count(self.ptr) }
  }

  pub unsafe fn borrow_environment_entry_by_index_const(&self, index: u64, name: *mut *const ::std::os::raw::c_char, value: *mut *const bt_value)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_borrow_environment_entry_by_index_const(self.ptr, index, name, value) }
  }

  pub unsafe fn borrow_environment_entry_value_by_name_const(&self, name: &str) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_borrow_environment_entry_value_by_name_const(self.ptr, name.as_ptr())} }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_trace_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn add_destruction_listener(&self, user_func: bt_trace_destruction_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtTraceAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_add_destruction_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub fn remove_destruction_listener(&self, listener_id: bt_listener_id) -> BtTraceRemoveListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_remove_destruction_listener(self.ptr, listener_id)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_put_ref(self.ptr) }
  }

}
pub struct BtTraceClassConst {
    ptr: *const bt_trace_class
}
impl BtTraceClassConst {
    pub fn empty() -> BtTraceClassConst {
        BtTraceClassConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_trace_class) -> BtTraceClassConst {
        BtTraceClassConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_stream_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_get_stream_class_count(self.ptr) }
  }

  pub fn borrow_stream_class_by_index_const(&self, index: u64) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_trace_class_borrow_stream_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_stream_class_by_id_const(&self, id: u64) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_trace_class_borrow_stream_class_by_id_const(self.ptr, id)} }
  }

  pub fn assigns_automatic_stream_class_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_trace_class_assigns_automatic_stream_class_id(self.ptr) as u32) != BT_FALSE }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn add_destruction_listener(&self, user_func: bt_trace_class_destruction_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtTraceClassAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_class_add_destruction_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub fn remove_destruction_listener(&self, listener_id: bt_listener_id) -> BtTraceClassRemoveListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_class_remove_destruction_listener(self.ptr, listener_id)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_put_ref(self.ptr) }
  }

}
pub struct BtTraceClass {
    ptr: *mut bt_trace_class
}
impl BtTraceClass {
    pub fn empty() -> BtTraceClass {
        BtTraceClass { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_trace_class) -> BtTraceClass {
        BtTraceClass { ptr }
    }
    pub fn as_const(&mut self) -> BtTraceClassConst {
      BtTraceClassConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub unsafe fn create(self_component: &BtSelfComponent) -> BtTraceClass {
    unsafe { BtTraceClass{ ptr:bt_trace_class_create(self_component.ptr)} }
  }

  pub fn get_stream_class_count(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_get_stream_class_count(self.ptr) }
  }

  pub fn borrow_stream_class_by_index(&mut self, index: u64) -> BtStreamClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClass{ ptr:bt_trace_class_borrow_stream_class_by_index(self.ptr, index)} }
  }

  pub fn borrow_stream_class_by_index_const(&self, index: u64) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_trace_class_borrow_stream_class_by_index_const(self.ptr, index)} }
  }

  pub fn borrow_stream_class_by_id(&mut self, id: u64) -> BtStreamClass {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClass{ ptr:bt_trace_class_borrow_stream_class_by_id(self.ptr, id)} }
  }

  pub fn borrow_stream_class_by_id_const(&self, id: u64) -> BtStreamClassConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtStreamClassConst{ ptr:bt_trace_class_borrow_stream_class_by_id_const(self.ptr, id)} }
  }

  pub fn set_assigns_automatic_stream_class_id(&mut self, assigns_automatic_stream_class_id: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_set_assigns_automatic_stream_class_id(self.ptr, if assigns_automatic_stream_class_id { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn assigns_automatic_stream_class_id(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_trace_class_assigns_automatic_stream_class_id(self.ptr) as u32) != BT_FALSE }
  }

  pub unsafe fn set_user_attributes(&mut self, user_attributes: &BtValueConst)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_set_user_attributes(self.ptr, user_attributes.ptr) }
  }

  pub fn borrow_user_attributes(&mut self) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_trace_class_borrow_user_attributes(self.ptr)} }
  }

  pub fn borrow_user_attributes_const(&self) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_trace_class_borrow_user_attributes_const(self.ptr)} }
  }

  pub unsafe fn add_destruction_listener(&self, user_func: bt_trace_class_destruction_listener_func, user_data: *mut ::std::os::raw::c_void, listener_id: *mut bt_listener_id) -> BtTraceClassAddListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_class_add_destruction_listener(self.ptr, user_func, user_data, listener_id)).unwrap() }
  }

  pub fn remove_destruction_listener(&self, listener_id: bt_listener_id) -> BtTraceClassRemoveListenerStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_trace_class_remove_destruction_listener(self.ptr, listener_id)).unwrap() }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_trace_class_put_ref(self.ptr) }
  }

}
pub struct BtValueConst {
    ptr: *const bt_value
}
impl BtValueConst {
    pub fn empty() -> BtValueConst {
        BtValueConst { ptr: std::ptr::null_mut() }
    }    
    pub fn from_ptr(ptr:*const bt_value) -> BtValueConst {
        BtValueConst { ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtValueType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_value_get_type(self.ptr)).unwrap() }
  }

  pub fn bool_get(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_bool_get(self.ptr) as u32) != BT_FALSE }
  }

  pub fn integer_unsigned_get(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_unsigned_get(self.ptr) }
  }

  pub fn integer_signed_get(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_signed_get(self.ptr) }
  }

  pub fn real_get(&self) -> f64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_real_get(self.ptr) }
  }

  pub fn string_get(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_value_string_get(self.ptr)) }
  }

  pub fn array_borrow_element_by_index_const(&self, index: u64) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_value_array_borrow_element_by_index_const(self.ptr, index)} }
  }

  pub fn array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_array_get_length(self.ptr) }
  }

  pub unsafe fn map_borrow_entry_value_const(&self, key: &str) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_value_map_borrow_entry_value_const(self.ptr, key.as_ptr())} }
  }

  pub unsafe fn map_foreach_entry_const(&self, user_func: bt_value_map_foreach_entry_const_func, user_data: *mut ::std::os::raw::c_void) -> BtValueMapForeachEntryConstStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_foreach_entry_const(self.ptr, user_func, user_data)).unwrap() }
  }

  pub fn map_get_size(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_map_get_size(self.ptr) }
  }

  pub unsafe fn map_has_entry(&self, key: &str) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_map_has_entry(self.ptr, key.as_ptr()) as u32) != BT_FALSE }
  }

  pub unsafe fn copy(&self, copy_value: *mut *mut bt_value) -> BtValueCopyStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_copy(self.ptr, copy_value)).unwrap() }
  }

  pub unsafe fn is_equal(&self, b_value: &BtValueConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_is_equal(self.ptr, b_value.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_put_ref(self.ptr) }
  }

}
pub struct BtValue {
    ptr: *mut bt_value
}
impl BtValue {
    pub fn empty() -> BtValue {
        BtValue { ptr: std::ptr::null_mut() }
    }
    pub fn from_ptr(ptr:*mut bt_value) -> BtValue {
        BtValue { ptr }
    }
    pub fn as_const(&mut self) -> BtValueConst {
      BtValueConst { ptr: self.ptr }
    }
    pub fn is_empty(&mut self) -> bool {
        self.ptr.is_null()
    }

  pub fn get_type(&self) -> BtValueType {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_u32(bt_value_get_type(self.ptr)).unwrap() }
  }

  pub fn bool_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_bool_create()} }
  }

  pub fn bool_create_init(raw_value: bool) -> BtValue {
    unsafe { BtValue{ ptr:bt_value_bool_create_init(if raw_value { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool })} }
  }

  pub fn bool_set(&mut self, raw_value: bool)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_bool_set(self.ptr, if raw_value { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool }) }
  }

  pub fn bool_get(&self) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_bool_get(self.ptr) as u32) != BT_FALSE }
  }

  pub fn integer_unsigned_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_integer_unsigned_create()} }
  }

  pub fn integer_unsigned_create_init(raw_value: u64) -> BtValue {
    unsafe { BtValue{ ptr:bt_value_integer_unsigned_create_init(raw_value)} }
  }

  pub fn integer_unsigned_set(&mut self, raw_value: u64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_unsigned_set(self.ptr, raw_value) }
  }

  pub fn integer_unsigned_get(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_unsigned_get(self.ptr) }
  }

  pub fn integer_signed_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_integer_signed_create()} }
  }

  pub fn integer_signed_create_init(raw_value: i64) -> BtValue {
    unsafe { BtValue{ ptr:bt_value_integer_signed_create_init(raw_value)} }
  }

  pub fn integer_signed_set(&mut self, raw_value: i64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_signed_set(self.ptr, raw_value) }
  }

  pub fn integer_signed_get(&self) -> i64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_integer_signed_get(self.ptr) }
  }

  pub fn real_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_real_create()} }
  }

  pub fn real_create_init(raw_value: f64) -> BtValue {
    unsafe { BtValue{ ptr:bt_value_real_create_init(raw_value)} }
  }

  pub fn real_set(&mut self, raw_value: f64)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_real_set(self.ptr, raw_value) }
  }

  pub fn real_get(&self) -> f64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_real_get(self.ptr) }
  }

  pub fn string_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_string_create()} }
  }

  pub unsafe fn string_create_init(raw_value: &str) -> BtValue {
    unsafe { BtValue{ ptr:bt_value_string_create_init(raw_value.as_ptr())} }
  }

  pub unsafe fn string_set(&mut self, raw_value: &str) -> BtValueStringSetStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_string_set(self.ptr, raw_value.as_ptr())).unwrap() }
  }

  pub fn string_get(&self) -> &CStr {
    debug_assert!(!self.ptr.is_null());
    unsafe { CStr::from_ptr(bt_value_string_get(self.ptr)) }
  }

  pub fn array_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_array_create()} }
  }

  pub unsafe fn array_append_element(&mut self, element_value: &BtValue) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_element(self.ptr, element_value.ptr)).unwrap() }
  }

  pub fn array_append_bool_element(&mut self, raw_value: bool) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_bool_element(self.ptr, if raw_value { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool })).unwrap() }
  }

  pub fn array_append_unsigned_integer_element(&mut self, raw_value: u64) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_unsigned_integer_element(self.ptr, raw_value)).unwrap() }
  }

  pub fn array_append_signed_integer_element(&mut self, raw_value: i64) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_signed_integer_element(self.ptr, raw_value)).unwrap() }
  }

  pub fn array_append_real_element(&mut self, raw_value: f64) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_real_element(self.ptr, raw_value)).unwrap() }
  }

  pub unsafe fn array_append_string_element(&mut self, raw_value: &str) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_string_element(self.ptr, raw_value.as_ptr())).unwrap() }
  }

  pub unsafe fn array_append_empty_array_element(&mut self, element_value: *mut *mut bt_value) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_empty_array_element(self.ptr, element_value)).unwrap() }
  }

  pub unsafe fn array_append_empty_map_element(&mut self, element_value: *mut *mut bt_value) -> BtValueArrayAppendElementStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_append_empty_map_element(self.ptr, element_value)).unwrap() }
  }

  pub unsafe fn array_set_element_by_index(&mut self, index: u64, element_value: &BtValue) -> BtValueArraySetElementByIndexStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_array_set_element_by_index(self.ptr, index, element_value.ptr)).unwrap() }
  }

  pub fn array_borrow_element_by_index(&mut self, index: u64) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_value_array_borrow_element_by_index(self.ptr, index)} }
  }

  pub fn array_borrow_element_by_index_const(&self, index: u64) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_value_array_borrow_element_by_index_const(self.ptr, index)} }
  }

  pub fn array_get_length(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_array_get_length(self.ptr) }
  }

  pub fn map_create() -> BtValue {
    unsafe { BtValue{ ptr:bt_value_map_create()} }
  }

  pub unsafe fn map_insert_entry(&mut self, key: &str, entry_value: &BtValue) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_entry(self.ptr, key.as_ptr(), entry_value.ptr)).unwrap() }
  }

  pub unsafe fn map_insert_bool_entry(&mut self, key: &str, raw_value: bool) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_bool_entry(self.ptr, key.as_ptr(), if raw_value { BT_TRUE as bt_bool } else { BT_FALSE as bt_bool })).unwrap() }
  }

  pub unsafe fn map_insert_unsigned_integer_entry(&mut self, key: &str, raw_value: u64) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_unsigned_integer_entry(self.ptr, key.as_ptr(), raw_value)).unwrap() }
  }

  pub unsafe fn map_insert_signed_integer_entry(&mut self, key: &str, raw_value: i64) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_signed_integer_entry(self.ptr, key.as_ptr(), raw_value)).unwrap() }
  }

  pub unsafe fn map_insert_real_entry(&mut self, key: &str, raw_value: f64) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_real_entry(self.ptr, key.as_ptr(), raw_value)).unwrap() }
  }

  pub unsafe fn map_insert_string_entry(&mut self, key: &str, raw_value: &str) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_string_entry(self.ptr, key.as_ptr(), raw_value.as_ptr())).unwrap() }
  }

  pub unsafe fn map_insert_empty_array_entry(&mut self, key: &str, entry_value: *mut *mut bt_value) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_empty_array_entry(self.ptr, key.as_ptr(), entry_value)).unwrap() }
  }

  pub unsafe fn map_insert_empty_map_entry(&mut self, key: &str, entry_value: *mut *mut bt_value) -> BtValueMapInsertEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_insert_empty_map_entry(self.ptr, key.as_ptr(), entry_value)).unwrap() }
  }

  pub unsafe fn map_borrow_entry_value(&mut self, key: &str) -> BtValue {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValue{ ptr:bt_value_map_borrow_entry_value(self.ptr, key.as_ptr())} }
  }

  pub unsafe fn map_borrow_entry_value_const(&self, key: &str) -> BtValueConst {
    debug_assert!(!self.ptr.is_null());
    unsafe { BtValueConst{ ptr:bt_value_map_borrow_entry_value_const(self.ptr, key.as_ptr())} }
  }

  pub unsafe fn map_foreach_entry(&mut self, user_func: bt_value_map_foreach_entry_func, user_data: *mut ::std::os::raw::c_void) -> BtValueMapForeachEntryStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_foreach_entry(self.ptr, user_func, user_data)).unwrap() }
  }

  pub unsafe fn map_foreach_entry_const(&self, user_func: bt_value_map_foreach_entry_const_func, user_data: *mut ::std::os::raw::c_void) -> BtValueMapForeachEntryConstStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_foreach_entry_const(self.ptr, user_func, user_data)).unwrap() }
  }

  pub fn map_get_size(&self) -> u64 {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_map_get_size(self.ptr) }
  }

  pub unsafe fn map_has_entry(&self, key: &str) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_map_has_entry(self.ptr, key.as_ptr()) as u32) != BT_FALSE }
  }

  pub unsafe fn map_extend(&mut self, extension_value: &BtValueConst) -> BtValueMapExtendStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_map_extend(self.ptr, extension_value.ptr)).unwrap() }
  }

  pub unsafe fn copy(&self, copy_value: *mut *mut bt_value) -> BtValueCopyStatus {
    debug_assert!(!self.ptr.is_null());
    unsafe { num::FromPrimitive::from_i32(bt_value_copy(self.ptr, copy_value)).unwrap() }
  }

  pub unsafe fn is_equal(&self, b_value: &BtValueConst) -> bool {
    debug_assert!(!self.ptr.is_null());
    unsafe { (bt_value_is_equal(self.ptr, b_value.ptr) as u32) != BT_FALSE }
  }

  pub fn get_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_get_ref(self.ptr) }
  }

  pub fn put_ref(&self)  {
    debug_assert!(!self.ptr.is_null());
    unsafe { bt_value_put_ref(self.ptr) }
  }

}